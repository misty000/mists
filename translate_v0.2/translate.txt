<div id="dependencies" class="section">
<h1>Dependencies</h1>
<p>Apart from the Scala library (see <a href="../../../project-info/current-versions/#current-versions" class="reference internal"><em>Current Version(s)</em></a> chapter) <em>spray-io</em> only depends on <a href="../../spray-util/#spray-util" class="reference internal"><em>spray-util</em></a> and
<em>akka-actor</em> (with ‘provided’ scope, i.e. you need to pull it in yourself).</p>
</div>
<div id="installation" class="section">
<h1>Installation</h1>
<p>The <a href="../../../project-info/maven-repository/#maven-repo" class="reference internal"><em>Maven Repository</em></a> chapter contains all the info about how to pull <em>spray-io</em> into your classpath.</p>
<p>Afterwards just <tt class="docutils literal"><span class="pre">import</span> <span class="pre">spray.io._</span></tt> to bring all relevant identifiers into scope.</p>
</div>
<div id="configuration" class="section">
<h1>Configuration</h1>
<p>Just like Akka <em>spray-io</em> relies on the <a href="https://github.com/typesafehub/config" class="reference external">typesafe config</a> library for configuration. As such its JAR contains a
<tt class="docutils literal"><span class="pre">reference.conf</span></tt> file holding the default values of all configuration settings. In your application you typically
provide an <tt class="docutils literal"><span class="pre">application.conf</span></tt>, in which you override Akka and/or <em>spray</em> settings according to your needs.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since <em>spray</em> uses the same configuration technique as Akka you might want to check out the
<a href="http://doc.akka.io/docs/akka/2.0.4/general/configuration.html" class="reference external">Akka Documentation on Configuration</a>.</p>
</div>
<p>This is the <tt class="docutils literal"><span class="pre">reference.conf</span></tt> of the <em>spray-io</em> module:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="c">##################################</span>
<span class="c"># spray-io Reference Config File #</span>
<span class="c">##################################</span>

<span class="c"># This is the reference config file that contains all the default settings.</span>
<span class="c"># Make your edits/overrides in your application.conf.</span>

spray.io <span class="o">{</span>

  <span class="c"># the number of threads to spread connection management across</span>
  <span class="c"># 1     = the root IOBridge manages all sockets itself (a good default for most applications)</span>
  <span class="c"># n &gt; 1 = the root IOBridge only handles ServerSockets for accepting new connections,</span>
  <span class="c">#         mgmt. of the connection sockets themselves is spread equally across n sub-bridges</span>
  <span class="nv">parallelism</span> <span class="o">=</span> 1

  <span class="c"># the size of the buffer to allocate (anew!) for every read from a socket</span>
  <span class="nb">read</span>-buffer-size <span class="o">=</span> 4k

  tcp <span class="o">{</span>
    <span class="c"># value for the SO_RCVBUF option for the created TCP sockets,</span>
    <span class="c"># set to zero to not explicitly set a value but use the default</span>
    receive-buffer-size <span class="o">=</span> 0

    <span class="c"># value for the SO_SNDBUF option for the created TCP sockets,</span>
    <span class="c"># set to zero to not explicitly set a value but use the default</span>
    send-buffer-size <span class="o">=</span> 0

    <span class="c"># indicates whether SO_KEEPALIVE should be set for the created TCP sockets,</span>
    <span class="c"># 0 -&gt; default, 1 -&gt; true, -1 -&gt; false</span>
    keep-alive <span class="o">=</span> 0

    <span class="c"># indicates whether TCP_NODELAY should be set for the created TCP sockets,</span>
    <span class="c"># 0 -&gt; default, 1 -&gt; disable Nagle's algorithm, -1 -&gt; enable Nagle's algorithm</span>
    no-delay <span class="o">=</span> 0
  <span class="o">}</span>

  <span class="c"># the dispatcher for IOBridges, no flexibility here</span>
  io-bridge-dispatcher <span class="o">=</span> <span class="o">{</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="s2">"akka.spray.io.IOBridgeDispatcherConfigurator"</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div id="iobridge" class="section">
<span id="id1"></span><h1>IOBridge</h1>
<p>The <tt class="docutils literal"><span class="pre">IOBridge</span></tt> is the central and lowest-level component of <em>spray-io</em>. It provides a thin and efficient
“adapter layer” between the network (i.e. sockets) and Akka actors.</p>
<p>There are two sides to this “adapter layer”:</p>
<dl class="docutils">
<dt>Outgoing network “commands”</dt>
<dd>Command messages coming in from the application, like “connect to a certain address”, “write this series of bytes” or
“close the connection” are applied to the respective connection/socket.</dd>
<dt>Incoming network “events”</dt>
<dd>Everything that happens on a socket managed by an <tt class="docutils literal"><span class="pre">IOBridge</span></tt>, like the acceptance of a new connection, the reading
of a series of bytes or the closing of the connection, is packaged in a respective event message and sent to
a “handler” actor responsible for the connection.</dd>
</dl>
<p>An <tt class="docutils literal"><span class="pre">IOBridge</span></tt> is implemented as an Akka actor using a special dispatcher, which allows it to “own” one private
thread, from which it manages one Java NIO selector. An <tt class="docutils literal"><span class="pre">IOBridge</span></tt> can easily handle many thousand connections, which
can be any mix of incoming and outgoing (i.e. server- and client-side) connections.</p>
<div id="parallelism" class="section">
<h2>Parallelism</h2>
<p>Depending on the <tt class="docutils literal"><span class="pre">parallelism</span></tt> config setting there will either only be one single <tt class="docutils literal"><span class="pre">IOBridge</span></tt> actor per
<tt class="docutils literal"><span class="pre">ActorSystem</span></tt> (<tt class="docutils literal"><span class="pre">parallellism</span> <span class="pre">=</span> <span class="pre">1</span></tt>, the default) or several ones. For many applications a single <tt class="docutils literal"><span class="pre">IOBridge</span></tt> is
perfectly capable of handling all network IO load. However, if you have a very IO-intensive application it might make
sense to distribute IO-handling across several threads. In these cases you can increase the <tt class="docutils literal"><span class="pre">parallelism</span></tt> setting
to values like 4 or 8, which causes the root <tt class="docutils literal"><span class="pre">IOBridge</span></tt> actor to only handle connection establishment itself and
distribute management of the individual connections equally across 4 or 8 “sub-bridge” actors, which are automatically
spawned.</p>
</div>
<div id="lifecycle" class="section">
<h2>Lifecycle</h2>
<p>Every <tt class="docutils literal"><span class="pre">ActorSystem</span></tt> can only contain a single (root) <tt class="docutils literal"><span class="pre">IOBridge</span></tt> that you create via the <tt class="docutils literal"><span class="pre">ioBridge</span></tt> method of
<em>sprays</em> <tt class="docutils literal"><span class="pre">IOExtension</span></tt>. Subsequent calls to this method will not create new instances but return the existing (root)
one.</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>
<span class="k">import</span> <span class="nn">spray.io.IOExtension</span>

<span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">()</span>

<span class="k">val</span> <span class="n">ioBridge</span> <span class="k">=</span> <span class="nc">IOExtension</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">ioBridge</span><span class="o">()</span>

<span class="c1">// start applications actors using the ioBridge instance</span>
<span class="c1">// ...</span>
</pre></div>
</div>
<p>Since an <tt class="docutils literal"><span class="pre">IOBridge</span></tt> is a regular Akka actor all commmunication with it happens asynchronously through messages,
which can be either of type <tt class="docutils literal"><span class="pre">Command</span></tt> or <tt class="docutils literal"><span class="pre">Event</span></tt>.</p>
</div>
<div id="commands" class="section">
<h2>Commands</h2>
<p>Once you have an <tt class="docutils literal"><span class="pre">IOBridge</span></tt> instance you’ll want to send commands to it.
These are all the defined commands:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// general commands not on the connection-level</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Bind</span><span class="o">(</span><span class="n">address</span><span class="k">:</span> <span class="kt">InetSocketAddress</span><span class="o">,</span> <span class="n">backlog</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">tag</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="o">())</span> <span class="k">extends</span> <span class="nc">Command</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Unbind</span><span class="o">(</span><span class="n">bindingKey</span><span class="k">:</span> <span class="kt">Key</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Command</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Connect</span><span class="o">(</span><span class="n">remoteAddress</span><span class="k">:</span> <span class="kt">InetSocketAddress</span><span class="o">,</span>
                   <span class="n">localAddress</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">InetSocketAddress</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span><span class="o">,</span>
                   <span class="n">tag</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="o">())</span> <span class="k">extends</span> <span class="nc">Command</span>
<span class="k">object</span> <span class="nc">Connect</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">host</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">port</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Connect</span> <span class="o">=</span> <span class="n">apply</span><span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">,</span> <span class="o">())</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">host</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">port</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">tag</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Connect</span> <span class="o">=</span>
    <span class="nc">Connect</span><span class="o">(</span><span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">),</span> <span class="nc">None</span><span class="o">,</span> <span class="n">tag</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">GetStats</span> <span class="k">extends</span> <span class="nc">Command</span>

<span class="c1">// connection-level commands</span>
<span class="k">trait</span> <span class="nc">ConnectionCommand</span> <span class="k">extends</span> <span class="nc">Command</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">handle</span><span class="k">:</span> <span class="kt">Handle</span>
<span class="o">}</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Register</span><span class="o">(</span><span class="n">handle</span><span class="k">:</span> <span class="kt">Handle</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ConnectionCommand</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Close</span><span class="o">(</span><span class="n">handle</span><span class="k">:</span> <span class="kt">Handle</span><span class="o">,</span>
                 <span class="n">reason</span><span class="k">:</span> <span class="kt">CloseCommandReason</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ConnectionCommand</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Send</span><span class="o">(</span><span class="n">handle</span><span class="k">:</span> <span class="kt">Handle</span><span class="o">,</span>
                <span class="n">buffers</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">ByteBuffer</span><span class="o">],</span>
                <span class="n">ack</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ConnectionCommand</span>
<span class="k">object</span> <span class="nc">Send</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">handle</span><span class="k">:</span> <span class="kt">Handle</span><span class="o">,</span> <span class="n">buffer</span><span class="k">:</span> <span class="kt">ByteBuffer</span><span class="o">)</span><span class="k">:</span> <span class="kt">Send</span> <span class="o">=</span>
    <span class="n">apply</span><span class="o">(</span><span class="n">handle</span><span class="o">,</span> <span class="n">buffer</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">handle</span><span class="k">:</span> <span class="kt">Handle</span><span class="o">,</span> <span class="n">buffer</span><span class="k">:</span> <span class="kt">ByteBuffer</span><span class="o">,</span> <span class="n">ack</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Any</span><span class="o">])</span><span class="k">:</span> <span class="kt">Send</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Send</span><span class="o">(</span><span class="n">handle</span><span class="o">,</span> <span class="n">buffer</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">,</span> <span class="n">ack</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">StopReading</span><span class="o">(</span><span class="n">handle</span><span class="k">:</span> <span class="kt">Handle</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ConnectionCommand</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">ResumeReading</span><span class="o">(</span><span class="n">handle</span><span class="k">:</span> <span class="kt">Handle</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ConnectionCommand</span>
</pre></div>
</div>
<p>And here is what action they instruct the bridge to perform:</p>
<dl class="docutils">
<dt>Bind</dt>
<dd>Start listening for incoming connections on a particular port. The sender receives a <tt class="docutils literal"><span class="pre">Bound</span></tt> event upon completion
as well as <tt class="docutils literal"><span class="pre">Connected</span></tt> events for each new incoming connection that has been accepted.</dd>
<dt>Unbind</dt>
<dd>Revert a previous <tt class="docutils literal"><span class="pre">Bind</span></tt>. The sender receives an <tt class="docutils literal"><span class="pre">Unbound</span></tt> event upon completion.</dd>
<dt>Connect</dt>
<dd>Connect to remote address. The sender receives a <tt class="docutils literal"><span class="pre">Connected</span></tt> event upon completion.</dd>
<dt>GetStats</dt>
<dd>Send the sender an <tt class="docutils literal"><span class="pre">IOBridge.StatsMap</span></tt> message containing simple statistics for the root bridge and all potentially
existing sub-bridges.</dd>
<dt>Register</dt>
<dd>Register the given <tt class="docutils literal"><span class="pre">Handle</span></tt> that was newly created as a result of a <tt class="docutils literal"><span class="pre">Connected</span></tt> event and start accepting
incoming data on its connection.</dd>
<dt>Close</dt>
<dd>Close the connection of the given <tt class="docutils literal"><span class="pre">Handle</span></tt>. If there are pending <tt class="docutils literal"><span class="pre">Send</span></tt> commands that haven’t yet been completed
the closing is queued. Special case: If the <tt class="docutils literal"><span class="pre">reason</span></tt> is <tt class="docutils literal"><span class="pre">ConfirmedClose</span></tt> the socket is not closed right away, but
rather via a full TCP FIN message exchange is performed. I.e. at first a TCP FIN message is sent and the peers
“ack’ing” FIN is awaited before the socket is closed.
Independently of when the socket is actually closed the handler of the connection receives a <tt class="docutils literal"><span class="pre">Closed</span></tt> event after
it has happened.</dd>
<dt>Send</dt>
<dd>Write the contents of the given ByteBuffers to the socket associated with the given handle. If <tt class="docutils literal"><span class="pre">ack</span></tt> is defined the
sender receives its content as a “send confirmation” message when all bytes have been successfully written to the
socket.</dd>
<dt>StopReading</dt>
<dd>Stop accepting incoming data from the socket associated with the given handle.</dd>
<dt>ResumeReading</dt>
<dd>Resume accepting incoming data from the socket associated with the given handle.</dd>
</dl>
</div>
<div id="events" class="section">
<h2>Events</h2>
<p>These are all the events that are generated by an <tt class="docutils literal"><span class="pre">IOBridge</span></tt> instance:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="c1">// "general" events not on the connection-level</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Bound</span><span class="o">(</span><span class="n">bindingKey</span><span class="k">:</span> <span class="kt">Key</span><span class="o">,</span> <span class="n">tag</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Event</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Unbound</span><span class="o">(</span><span class="n">bindingKey</span><span class="k">:</span> <span class="kt">Key</span><span class="o">,</span> <span class="n">tag</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Event</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Connected</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">Key</span><span class="o">,</span> <span class="n">tag</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Event</span>

<span class="c1">// connection-level events</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Closed</span><span class="o">(</span><span class="n">handle</span><span class="k">:</span> <span class="kt">Handle</span><span class="o">,</span> <span class="n">reason</span><span class="k">:</span> <span class="kt">ClosedEventReason</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Event</span> <span class="k">with</span> <span class="nc">IOClosed</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Received</span><span class="o">(</span><span class="n">handle</span><span class="k">:</span> <span class="kt">Handle</span><span class="o">,</span> <span class="n">buffer</span><span class="k">:</span> <span class="kt">ByteBuffer</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Event</span>
</pre></div>
</div>
<p>And these are their semantics:</p>
<dl class="docutils">
<dt>Bound</dt>
<dd>Sent as confirmation to the sender of a preceding <tt class="docutils literal"><span class="pre">Bind</span></tt> command.</dd>
<dt>Unbound</dt>
<dd>Sent as confirmation to the sender of a preceding <tt class="docutils literal"><span class="pre">Unbind</span></tt> command.</dd>
<dt>Connected</dt>
<dd>Sent after a new connection has been established to the sender of a preceding <tt class="docutils literal"><span class="pre">Bind</span></tt> or <tt class="docutils literal"><span class="pre">Connect</span></tt> command.</dd>
<dt>Closed</dt>
<dd>Sent to the handler actor after a connection has been closed.</dd>
<dt>Received</dt>
<dd>Sent to the handler actor after a chunk of data has been read from the connections socket. Will never contain more
than the number of bytes configured as <tt class="docutils literal"><span class="pre">read-buffer-size</span></tt> in the <tt class="docutils literal"><span class="pre">IOBridgeSettings</span></tt>.</dd>
</dl>
</div>
<div id="handle" class="section">
<h2>Handle</h2>
<p>An <tt class="docutils literal"><span class="pre">IOBridge</span></tt> identifies connections using a “handle”, which can be any object implementing in the <tt class="docutils literal"><span class="pre">Handle</span></tt>
interface:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">trait</span> <span class="nc">Handle</span> <span class="o">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The key identifying the connection.</span>
<span class="cm">   */</span>
  <span class="k">def</span> <span class="n">key</span><span class="k">:</span> <span class="kt">Key</span>

  <span class="cm">/**</span>
<span class="cm">   * The actor handling events coming in from the network.</span>
<span class="cm">   * If ConnectionActors are used this is the connection actor.</span>
<span class="cm">   */</span>
  <span class="k">def</span> <span class="n">handler</span><span class="k">:</span> <span class="kt">ActorRef</span>

  <span class="cm">/**</span>
<span class="cm">   * A custom, application-defined tag object that can be attached</span>
<span class="cm">   * to a `Bind` or `Connect` command and is made available to the application</span>
<span class="cm">   * through the handle. Currently it is used for connection-specific</span>
<span class="cm">   * enabling/disabling of encryption (see `SslTlsSupport.Enabling` trait)</span>
<span class="cm">   * or for custom log marking (see `LogMarking` trait).</span>
<span class="cm">   */</span>
  <span class="k">def</span> <span class="n">tag</span><span class="k">:</span> <span class="kt">Any</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The creation of actual handle instances is delegated to the user. This enables the lookup-free implementation of the
application logic, since all connection-specific event messages always carry the handle instance that was created by
the application and, as such, provide direct access to application data.</p>
<p>The typical pattern is that the application creates a new <tt class="docutils literal"><span class="pre">Handle</span></tt> instance after the reception of a <tt class="docutils literal"><span class="pre">Connected</span></tt>
event, which is the only way to get a hold of the required <tt class="docutils literal"><span class="pre">Key</span></tt> for the handle. After handle creation the application
then registers it with the <tt class="docutils literal"><span class="pre">IOBridge</span></tt> via a <tt class="docutils literal"><span class="pre">Register</span></tt> command.</p>
</div>
</div>
<div id="ioclient" class="section">
<span id="id1"></span><h1>IOClient</h1>
<p>The <a href="https://github.com/spray/spray/blob/master/spray-io/src/main/scala/spray/io/IOClient.scala" class="reference external">IOClient</a> is a simple actor base class for client-side networking components.
It builds upon an <a href="../io-bridge/#iobridge" class="reference internal"><em>IOBridge</em></a> and provides client-side connection management. An <tt class="docutils literal"><span class="pre">IOClient</span></tt> cannot be used
directly but has to be subclassed (potentially mixing in the <a href="../connection-actors/#connectionactors" class="reference internal"><em>ConnectionActors</em></a> trait) and augmented
with the custom application logic that actually does whatever the specific networking client is supposed to do.
In that sense the <tt class="docutils literal"><span class="pre">IOClient</span></tt> class merely provides the “boilerplate” logic common to most <em>spray-io</em> based network
clients.</p>
<p>After having created an <tt class="docutils literal"><span class="pre">IOClient</span></tt> actor instance you typically send it a <tt class="docutils literal"><span class="pre">Connect</span></tt> message, which is either
responded to with a <tt class="docutils literal"><span class="pre">Connected</span></tt> event after the connection has been established, or a <tt class="docutils literal"><span class="pre">Status.Failure</span></tt> message
(which is automatically turned into Future failures, if the <tt class="docutils literal"><span class="pre">Connect</span></tt> was sent with an <tt class="docutils literal"><span class="pre">ask</span></tt>).</p>
<p>In its original form, without mixing in the <a href="../connection-actors/#connectionactors" class="reference internal"><em>ConnectionActors</em></a> trait, an <tt class="docutils literal"><span class="pre">IOClient</span></tt> designates itself as the
handler of all network events. You will therefore have to augment its <tt class="docutils literal"><span class="pre">receive</span></tt> behavior with your own logic
generating the appropriate <tt class="docutils literal"><span class="pre">Send</span></tt> commands as well as handling incoming <tt class="docutils literal"><span class="pre">Received</span></tt> events.</p>
<div id="examples" class="section">
<h2>Examples</h2>
<p>One example of a network client based on the <tt class="docutils literal"><span class="pre">IOClient</span></tt> is the <em>spray-can</em> <a href="../../spray-can/http-client/#httpclient" class="reference internal"><em>HttpClient</em></a>. You might find
<a href="https://github.com/spray/spray/blob/master/spray-can/src/main/scala/spray/can/client/HttpClient.scala" class="reference external">its sources</a> quite readable.</p>
<p>Another (admittedly very contrived and overly simplified) example is presented here:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">java.util.concurrent.TimeUnit._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration.Duration</span>
<span class="k">import</span> <span class="nn">akka.util.Timeout</span>
<span class="k">import</span> <span class="nn">akka.pattern.ask</span>
<span class="k">import</span> <span class="nn">akka.actor._</span>
<span class="k">import</span> <span class="nn">spray.util._</span>
<span class="k">import</span> <span class="nn">spray.io._</span>

<span class="k">class</span> <span class="nc">EchoClient</span><span class="o">(</span><span class="nc">_ioBridge</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">IOClient</span><span class="o">(</span><span class="nc">_ioBridge</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">pingSender</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">ActorRef</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="n">myReceive</span> <span class="n">orElse</span> <span class="k">super</span><span class="o">.</span><span class="n">receive</span>

  <span class="k">def</span> <span class="n">myReceive</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">EchoClient</span><span class="o">.</span><span class="nc">Ping</span><span class="o">(</span><span class="n">handle</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">pingSender</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">sender</span><span class="o">)</span>
      <span class="n">handle</span><span class="o">.</span><span class="n">ioBridge</span> <span class="o">!</span> <span class="nc">IOBridge</span><span class="o">.</span><span class="nc">Send</span><span class="o">(</span><span class="n">handle</span><span class="o">,</span> <span class="nc">BufferBuilder</span><span class="o">(</span><span class="s">"PING"</span><span class="o">).</span><span class="n">toByteBuffer</span><span class="o">)</span>

    <span class="k">case</span> <span class="nc">IOClient</span><span class="o">.</span><span class="nc">Received</span><span class="o">(</span><span class="n">handle</span><span class="o">,</span> <span class="n">buffer</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">pingSender</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="k">_</span> <span class="o">!</span> <span class="nc">EchoClient</span><span class="o">.</span><span class="nc">PingResponse</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="n">drainToString</span><span class="o">))</span>

    <span class="k">case</span> <span class="nc">IOClient</span><span class="o">.</span><span class="nc">Closed</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">reason</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="o">(</span><span class="s">"Connection closed: {}"</span><span class="o">,</span> <span class="n">reason</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">EchoClient</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Ping</span><span class="o">(</span><span class="n">handle</span><span class="k">:</span> <span class="kt">Connection</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Command</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">PingResponse</span><span class="o">(</span><span class="n">response</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Event</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">EchoServer</span><span class="o">(</span><span class="nc">_ioBridge</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">IOServer</span><span class="o">(</span><span class="nc">_ioBridge</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="k">super</span><span class="o">.</span><span class="n">receive</span> <span class="n">orElse</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">IOServer</span><span class="o">.</span><span class="nc">Received</span><span class="o">(</span><span class="n">handle</span><span class="o">,</span> <span class="n">buffer</span><span class="o">)</span> <span class="k">if</span> <span class="n">buffer</span><span class="o">.</span><span class="n">duplicate</span><span class="o">.</span><span class="n">drainToString</span> <span class="o">==</span> <span class="s">"PING"</span> <span class="k">=&gt;</span>
      <span class="n">sender</span> <span class="o">!</span> <span class="nc">IOBridge</span><span class="o">.</span><span class="nc">Send</span><span class="o">(</span><span class="n">handle</span><span class="o">,</span> <span class="nc">BufferBuilder</span><span class="o">(</span><span class="s">"PONG"</span><span class="o">).</span><span class="n">toByteBuffer</span><span class="o">)</span>
      <span class="n">sender</span> <span class="o">!</span> <span class="nc">IOBridge</span><span class="o">.</span><span class="nc">Close</span><span class="o">(</span><span class="n">handle</span><span class="o">,</span> <span class="nc">ConnectionCloseReasons</span><span class="o">.</span><span class="nc">CleanClose</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">()</span>

<span class="k">val</span> <span class="n">ioBridge</span> <span class="k">=</span> <span class="nc">IOExtension</span><span class="o">(</span><span class="n">system</span><span class="o">).</span><span class="n">ioBridge</span><span class="o">()</span>

<span class="k">val</span> <span class="n">server</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">EchoServer</span><span class="o">(</span><span class="n">ioBridge</span><span class="o">)),</span> <span class="s">"server"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">client</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">EchoClient</span><span class="o">(</span><span class="n">ioBridge</span><span class="o">)),</span> <span class="s">"client"</span><span class="o">)</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">timeout</span><span class="k">:</span> <span class="kt">Timeout</span> <span class="o">=</span> <span class="nc">Duration</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">SECONDS</span><span class="o">)</span> <span class="c1">// timeout for the asks below</span>

<span class="c1">// bind the server to a local port and wait for it to come up</span>
<span class="n">server</span><span class="o">.</span><span class="n">ask</span><span class="o">(</span><span class="nc">IOServer</span><span class="o">.</span><span class="nc">Bind</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span> <span class="mi">46468</span><span class="o">)).</span><span class="n">await</span>

<span class="c1">// ask the client to connect to the server and wait for the connection to come up</span>
<span class="k">val</span> <span class="nc">IOClient</span><span class="o">.</span><span class="nc">Connected</span><span class="o">(</span><span class="n">handle</span><span class="o">)</span> <span class="k">=</span> <span class="n">client</span><span class="o">.</span><span class="n">ask</span><span class="o">(</span><span class="nc">IOClient</span><span class="o">.</span><span class="nc">Connect</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span> <span class="mi">46468</span><span class="o">)).</span><span class="n">await</span>

<span class="c1">// ping the server and wait for the response</span>
<span class="k">val</span> <span class="nc">EchoClient</span><span class="o">.</span><span class="nc">PingResponse</span><span class="o">(</span><span class="n">response</span><span class="o">)</span> <span class="k">=</span> <span class="n">client</span><span class="o">.</span><span class="n">ask</span><span class="o">(</span><span class="nc">EchoClient</span><span class="o">.</span><span class="nc">Ping</span><span class="o">(</span><span class="n">handle</span><span class="o">)).</span><span class="n">await</span>

<span class="n">response</span> <span class="o">===</span> <span class="s">"PONG"</span>

<span class="n">system</span><span class="o">.</span><span class="n">shutdown</span><span class="o">()</span>
</pre></div>
</div>
<p>Note than this example uses blocking calls to wait for future results, which is something that you probably do not
want to do in a performance-sensitive part of your application. Also, for brevity reasons the example omits all
error handling logic.</p>
</div>
<div id="messaging-protocol" class="section">
<h2>Messaging Protocol</h2>
<p>The convention in <em>spray</em> is to make all custom message types that a certain actor consumes or sends out available
in the actors companion object. In this regard the <tt class="docutils literal"><span class="pre">IOClient</span></tt> is no exception, you can find all commands and events
that an <tt class="docutils literal"><span class="pre">IOClient</span></tt> works with in <a href="https://github.com/spray/spray/blob/master/spray-io/src/main/scala/spray/io/IOClient.scala" class="reference external">its companion object</a></p>
</div>
</div>
<div id="ioserver" class="section">
<span id="id1"></span><h1>IOServer</h1>
<p>The <a href="https://github.com/spray/spray/blob/master/spray-io/src/main/scala/spray/io/IOServer.scala" class="reference external">IOServer</a> is a simple actor base class for server-side networking components.
It builds upon an <a href="../io-bridge/#iobridge" class="reference internal"><em>IOBridge</em></a> and provides server-side connection management. An <tt class="docutils literal"><span class="pre">IOServer</span></tt> cannot be used
directly but has to be subclassed (potentially mixing in the <a href="../connection-actors/#connectionactors" class="reference internal"><em>ConnectionActors</em></a> trait) and augmented
with the custom application logic that actually does whatever the specific networking server is supposed to do.
In that sense the <tt class="docutils literal"><span class="pre">IOServer</span></tt> class merely provides the “boilerplate” logic common to most <em>spray-io</em> based network
servers.</p>
<p>After having created an <tt class="docutils literal"><span class="pre">IOServer</span></tt> actor instance you typically send it a <tt class="docutils literal"><span class="pre">Bind</span></tt> message, which causes it to listen
for incoming connections on a specific interface/port. When the server is up the sender of the <tt class="docutils literal"><span class="pre">Bind</span></tt> receives a
<tt class="docutils literal"><span class="pre">Bound</span></tt> event and subsequently a <tt class="docutils literal"><span class="pre">Connected</span></tt> event for every new connection that has been accepted.
Once bound the server can be unbound with an <tt class="docutils literal"><span class="pre">Unbind</span></tt> command.</p>
<p>In its original form, without mixing in the <a href="../connection-actors/#connectionactors" class="reference internal"><em>ConnectionActors</em></a> trait, an <tt class="docutils literal"><span class="pre">IOServer</span></tt> designates itself as the
handler of all network events. You will therefore have to augment its <tt class="docutils literal"><span class="pre">receive</span></tt> behavior with your own logic
handling incoming <tt class="docutils literal"><span class="pre">Received</span></tt> events as well as generating the appropriate <tt class="docutils literal"><span class="pre">Send</span></tt> commands.</p>
<div id="examples" class="section">
<h2>Examples</h2>
<p>One example of a network server based on the <tt class="docutils literal"><span class="pre">IOServer</span></tt> is the <em>spray-can</em> <a href="../../spray-can/http-server/#httpserver" class="reference internal"><em>HttpServer</em></a>. You might find
<a href="https://github.com/spray/spray/blob/master/spray-can/src/main/scala/spray/can/server/HttpServer.scala" class="reference external">its sources</a> quite readable.</p>
<p>Another example is the <tt class="docutils literal"><span class="pre">echo-server</span></tt> implementation that can be found <a href="https://github.com/spray/spray/blob/master/examples/spray-io/echo-server/src/main/scala/spray/examples/Main.scala" class="reference external">here</a>.
It presents a simple echo server that you can <tt class="docutils literal"><span class="pre">telnet</span></tt> to.</p>
<p>To run it, simply check out the <em>spray</em> codebase and run <tt class="docutils literal"><span class="pre">sbt</span> <span class="pre">"project</span> <span class="pre">echo-server"</span> <span class="pre">run</span></tt>.</p>
</div>
<div id="messaging-protocol" class="section">
<h2>Messaging Protocol</h2>
<p>The convention in <em>spray</em> is to make all custom message types that a certain actor consumes or sends out available
in the actors companion object. In this regard the <tt class="docutils literal"><span class="pre">IOServer</span></tt> is no exception, you can find all commands and events
that an <tt class="docutils literal"><span class="pre">IOServer</span></tt> works with in <a href="https://github.com/spray/spray/blob/master/spray-io/src/main/scala/spray/io/IOServer.scala" class="reference external">its companion object</a></p>
</div>
</div>
<div id="connectionactors" class="section">
<span id="id1"></span><h1>ConnectionActors</h1>
<p>The <a href="https://github.com/spray/spray/blob/master/spray-io/src/main/scala/spray/io/ConnectionActors.scala" class="reference external">ConnectionActors</a> trait can be mixed into either an <a href="../io-client/#ioclient" class="reference internal"><em>IOClient</em></a> or an <a href="../io-server/#ioserver" class="reference internal"><em>IOServer</em></a> and changes their
behavior to create a fresh <tt class="docutils literal"><span class="pre">IOConnectionActor</span></tt> for every newly established connection. These “connection actors”
encapsulate connection-specific state and serve as handlers for all events coming in from the underlying
<a href="../io-bridge/#iobridge" class="reference internal"><em>IOBridge</em></a>.</p>
<p>Theoretically, in order to implement your own client- or server logic, it would suffice if <em>spray-io</em> gave you the
ability to somehow place your own <tt class="docutils literal"><span class="pre">Actor.Receive</span></tt> partial function directly in these connection actors.
However, implementing non-trivial client- or server logic in a single, monolithic actor usually doesn’t yield very
readable and maintainable code. Rather an architecturally clean implementation would split up the logic into different,
loosely coupled chunks, each handling only one very tightly scoped aspect of the whole client or server.</p>
<p><em>spray-io</em> provides an infrastructure for this type of architecture with the concept of <a href="../pipelining/#pipelining" class="reference internal"><em>Pipelining</em></a>, for which
the <a href="https://github.com/spray/spray/blob/master/spray-io/src/main/scala/spray/io/ConnectionActors.scala" class="reference external">ConnectionActors</a> trait forms the basis.</p>
</div>
<div id="pipelining" class="section">
<span id="id1"></span><h1>Pipelining</h1>
<p>In order to form a proper foundation for architecturally sound network client- and server implementations <em>spray-io</em>
supports <em>pipelining</em>. The basic idea is to design a client or server as a series of loosely coupled <em>pipeline stages</em>,
with each stage implementing only one tightly scoped aspect of the whole logic.
Pipeline stages can be assembled into different configurations in way that is configurable at runtime, which allows
a user of the client or server to enable or disable selected parts according to their needs.</p>
<p>The <em>spray-io</em> pipelining architecture is loosely based on the one from <a href="http://www.jboss.org/netty" class="reference external">Netty</a>. However, in contrast to its Java-based
“role model” it can leverage Scala language features such as pattern matching for a cleaner and more concise
implementation without sacrificing performance.</p>
<div id="architecture" class="section">
<h2>Architecture</h2>
<p>The following diagram outlines the major concepts:</p>
<img src="../../../_images/pipelining.svg"><p>When a connection actor is started by its parent (which is either an <a href="../io-client/#ioclient" class="reference internal"><em>IOClient</em></a> or an <a href="../io-server/#ioserver" class="reference internal"><em>IOServer</em></a>) it
immediately constructs two “pipelines”, a <em>command pipeline</em> and an <em>event pipeline</em>. A pipeline consists of one or
more <em>pipeline stages</em>, through which messages travel unidirectionally.</p>
<p>In the command pipeline <tt class="docutils literal"><span class="pre">Command</span></tt> messages are passed from higher-level stages down to lower-level stages until they
hit the final stage, which, in most cases, passes them on to the underlying <a href="../io-bridge/#iobridge" class="reference internal"><em>IOBridge</em></a>. In the event pipeline
<tt class="docutils literal"><span class="pre">Event</span></tt> message flow in the other direction, from the <a href="../io-bridge/#iobridge" class="reference internal"><em>IOBridge</em></a> up through all its stages.</p>
<p>Pipeline stages form the entities, into which you typically structure your client or server logic. Conceptually there
are four types of stages:</p>
<ul class="simple">
<li>“Command-only stages”, which inject logic only into the command pipeline</li>
<li>“Event-only stages”, which inject logic only into the event pipeline</li>
<li>“Full stages”, which inject logic into both pipelines</li>
<li>“Empty stages”, which don’t add any logic (they serve as neutral element for pipeline combination)</li>
</ul>
</div>
<div id="the-pipelinestage-trait" class="section">
<h2>The <em>PipelineStage</em> trait</h2>
<p>Pipeline stages are modelled by the <tt class="docutils literal"><span class="pre">PipelineStage</span></tt> trait, whose central element is the <tt class="docutils literal"><span class="pre">build</span></tt> method:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">def</span> <span class="n">build</span><span class="o">(</span><span class="n">context</span><span class="k">:</span> <span class="kt">PipelineContext</span><span class="o">,</span>
          <span class="n">commandPL</span><span class="k">:</span> <span class="kt">Pipeline</span><span class="o">[</span><span class="kt">Command</span><span class="o">],</span>
          <span class="n">eventPL</span><span class="k">:</span> <span class="kt">Pipeline</span><span class="o">[</span><span class="kt">Event</span><span class="o">])</span><span class="k">:</span> <span class="kt">Pipelines</span>
</pre></div>
</div>
<p>whereby <tt class="docutils literal"><span class="pre">Pipeline</span></tt> is the following simple type alias:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">type</span> <span class="kt">Pipeline</span><span class="o">[</span><span class="kt">-T</span><span class="o">]</span> <span class="k">=</span> <span class="n">T</span> <span class="k">=&gt;</span> <span class="nc">Unit</span>
</pre></div>
</div>
<p>So, when seen from the outside, a pipeline appears simply as a sink for messages of specific type.</p>
<p>The <tt class="docutils literal"><span class="pre">build</span></tt> method of a <tt class="docutils literal"><span class="pre">PipelineStage</span></tt> is called every time a new connection actor is created. Apart from the
<tt class="docutils literal"><span class="pre">PipelineContext</span></tt> the <tt class="docutils literal"><span class="pre">build</span></tt> method receives its downstream “tail” pipelines as arguments.
The result of the <tt class="docutils literal"><span class="pre">build</span></tt> method is an instance of the <tt class="docutils literal"><span class="pre">Pipelines</span></tt> trait, which simply groups together the new
command and event pipelines, after the stage has prepended them with its own logic:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">trait</span> <span class="nc">Pipelines</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">commandPipeline</span><span class="k">:</span> <span class="kt">Pipeline</span><span class="o">[</span><span class="kt">Command</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">eventPipeline</span><span class="k">:</span> <span class="kt">Pipeline</span><span class="o">[</span><span class="kt">Event</span><span class="o">]</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The dotted lines in the following diagram illustrate what the <tt class="docutils literal"><span class="pre">build</span></tt> method returns:</p>
<img src="../../../_images/PipelineStage.svg"></div>
<div id="execution-model" class="section">
<h2>Execution Model</h2>
<p>Since pipelines are simple functions <tt class="docutils literal"><span class="pre">T</span> <span class="pre">=&gt;</span> <span class="pre">Unit</span></tt> (with <tt class="docutils literal"><span class="pre">T</span></tt> being either <tt class="docutils literal"><span class="pre">Command</span></tt> or <tt class="docutils literal"><span class="pre">Event</span></tt>) each stage is
in complete control of the message flow. It can not only modify messages, it can also hold, discard or multiply them in
any way. Additionally it can generate messages of the opposite type and push them into the respective downstream tail
pipeline. For example, the <a href="https://github.com/spray/spray/blob/master/spray-can/src/main/scala/spray/can/server/RequestParsing.scala" class="reference external">RequestParsing</a> stage of the <a href="../../spray-can/#spray-can" class="reference internal"><em>spray-can</em></a> <a href="../../spray-can/http-server/#httpserver" class="reference internal"><em>HttpServer</em></a> generates commands
that complete a request with an error response whenever a request parsing error is encountered.</p>
<p>Also, all pipeline code is always executed in the context of the connection actor and therefore isolated to a specific
connection. As such, keeping mutable, connection-specific state within a pipeline stage is not a problem.</p>
<p>When another actor gets a hold of the connection actors <tt class="docutils literal"><span class="pre">ActorRef</span></tt> (e.g. because a pipeline stage sent an
<tt class="docutils literal"><span class="pre">IOPeer.Tell</span></tt> command using the connection actor as <tt class="docutils literal"><span class="pre">sender</span></tt>) and itself sends a message to the connection actor,
this message hits the connection actors <tt class="docutils literal"><span class="pre">receive</span></tt> behavior, which is defined like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">def</span> <span class="n">receive</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Command</span> <span class="o">=&gt;</span> <span class="n">pipelines</span><span class="o">.</span><span class="n">commandPipeline</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Event</span> <span class="o">=&gt;</span> <span class="n">pipelines</span><span class="o">.</span><span class="n">eventPipeline</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Status</span><span class="o">.</span><span class="nc">Failure</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">CommandException</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">pipelines</span><span class="o">.</span><span class="n">eventPipeline</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Terminated</span><span class="o">(</span><span class="n">actor</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">pipelines</span><span class="o">.</span><span class="n">eventPipeline</span><span class="o">(</span><span class="nc">IOPeer</span><span class="o">.</span><span class="nc">ActorDeath</span><span class="o">(</span><span class="n">actor</span><span class="o">))</span>
<span class="o">}</span>
</pre></div>
</div>
<p>As you can see the connection actor feeds all incoming <tt class="docutils literal"><span class="pre">Command</span></tt> or <tt class="docutils literal"><span class="pre">Event</span></tt> messages directly into its respective
pipeline. This behavior can also be useful from within a pipeline stage itself, because it allows any stage to push a
command or event into the <em>beginning</em> of the respective pipeline, rather than just its own downstream pipeline “tail”.
All that stage has to do is to send the message to its own connection actor.</p>
</div>
<div id="creating-pipeline-stages" class="section">
<h2>Creating Pipeline Stages</h2>
<p>Since the <tt class="docutils literal"><span class="pre">PipelineStage</span></tt> trait is a regular Scala trait you can implement it in any way you like. However, the
following template, which illustrates how pipeline stage implementations within <em>spray</em> itself are
structured, might give you a good starting point:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">object</span> <span class="nc">PipelineStageName</span> <span class="o">{</span>

  <span class="c1">// members defined here are global across</span>
  <span class="c1">// all server and client instances</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(&lt;</span><span class="n">arguments</span><span class="o">&gt;)</span><span class="k">:</span> <span class="kt">PipelineStage</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PipelineStage</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(...)</span> <span class="c1">// argument verification</span>

    <span class="c1">// members defined here exist once per</span>
    <span class="c1">// server or client instance</span>

    <span class="k">def</span> <span class="n">build</span><span class="o">(</span><span class="n">context</span><span class="k">:</span> <span class="kt">PipelineContext</span><span class="o">,</span>
              <span class="n">commandPL</span><span class="k">:</span> <span class="kt">Pipeline</span><span class="o">[</span><span class="kt">Command</span><span class="o">],</span>
              <span class="n">eventPL</span><span class="k">:</span> <span class="kt">Pipeline</span><span class="o">[</span><span class="kt">Event</span><span class="o">])</span><span class="k">:</span> <span class="kt">Pipelines</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pipelines</span> <span class="o">{</span>

      <span class="c1">// members defined here exist</span>
      <span class="c1">// once per connection</span>

      <span class="k">val</span> <span class="n">commandPipeline</span><span class="k">:</span> <span class="kt">Pipeline</span><span class="o">[</span><span class="kt">Command</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="o">...</span> <span class="k">=&gt;</span>
          <span class="c1">// handle "interesting" commands, send commands</span>
          <span class="c1">// and events to the commandPL or eventPL</span>

        <span class="k">case</span> <span class="n">cmd</span> <span class="k">=&gt;</span> <span class="c1">// pass through all "unknown" commands</span>
          <span class="n">commandPL</span><span class="o">(</span><span class="n">cmd</span><span class="o">)</span>
      <span class="o">}</span>

      <span class="k">val</span> <span class="n">eventPipeline</span><span class="k">:</span> <span class="kt">Pipeline</span><span class="o">[</span><span class="kt">Event</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
        <span class="k">case</span> <span class="o">...</span> <span class="k">=&gt;</span>
          <span class="c1">// handle "interesting" events, send commands</span>
          <span class="c1">// and events to the commandPL or eventPL</span>

        <span class="k">case</span> <span class="n">ev</span> <span class="k">=&gt;</span> <span class="c1">// pass through all "unknown" events</span>
          <span class="n">eventPL</span><span class="o">(</span><span class="n">ev</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">////////////// COMMANDS and EVENTS //////////////</span>

  <span class="c1">// definition of all commands and events specific to this pipeline stage</span>

  <span class="k">case</span> <span class="k">class</span> <span class="nc">MyCommand</span><span class="o">(...)</span> <span class="k">extends</span> <span class="nc">Command</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">MyEvent</span><span class="o">(...)</span> <span class="k">extends</span> <span class="nc">Event</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This template shows a “full stage``, with logic injected into both pipelines. If your stage only requires logic in one
of the pipelines simply pass through the other one unchanged. For example, if your stage is a “command-only” stage you’d
implement the <tt class="docutils literal"><span class="pre">eventPipeline</span></tt> member of the <tt class="docutils literal"><span class="pre">Pipelines</span></tt> trait as such:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">eventPipeline</span> <span class="k">=</span> <span class="n">eventPL</span>
</pre></div>
</div>
<p>Check out the <a href="https://github.com/spray/spray/blob/master/spray-can/src/main/scala/spray/can/server/ResponseRendering.scala" class="reference external">ResponseRendering</a> stage of the <a href="../../spray-can/#spray-can" class="reference internal"><em>spray-can</em></a> <a href="../../spray-can/http-server/#httpserver" class="reference internal"><em>HttpServer</em></a> as an
example of a “command-only stage” and the <a href="../predefined-stages/#tickgenerator" class="reference internal"><em>TickGenerator</em></a> as an “event-only stage” example.</p>
</div>
<div id="combining-pipeline-stages" class="section">
<h2>Combining Pipeline Stages</h2>
<p>Two <tt class="docutils literal"><span class="pre">PipelineStage</span></tt> instances can be combined into single one with the <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> operator. Additionally an expression
creating a <tt class="docutils literal"><span class="pre">PipelineStage</span></tt> can be made optional by prepending it with a <tt class="docutils literal"><span class="pre">&lt;boolean&gt;</span> <span class="pre">?</span></tt> modifier.</p>
<p>To understand what this means check out this simplified version of the definition of the <a href="../../spray-can/#spray-can" class="reference internal"><em>spray-can</em></a>
<a href="https://github.com/spray/spray/blob/master/spray-can/src/main/scala/spray/can/client/HttpClient.scala" class="reference external">HttpClient</a> pipeline:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="nc">ClientFrontend</span><span class="o">(...)</span> <span class="o">&gt;&gt;</span>
<span class="o">(</span><span class="nc">ResponseChunkAggregationLimit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="nc">ResponseChunkAggregation</span><span class="o">(...)</span> <span class="o">&gt;&gt;</span>
<span class="nc">ResponseParsing</span><span class="o">(...)</span> <span class="o">&gt;&gt;</span>
<span class="nc">RequestRendering</span><span class="o">(...)</span> <span class="o">&gt;&gt;</span>
<span class="o">(</span><span class="n">settings</span><span class="o">.</span><span class="nc">IdleTimeout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="nc">ConnectionTimeouts</span><span class="o">(...)</span> <span class="o">&gt;&gt;</span>
<span class="nc">SslTlsSupport</span><span class="o">(...)</span> <span class="o">&gt;&gt;</span>
<span class="o">(</span><span class="nc">ReapingCycle</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nc">IdleTimeout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="nc">TickGenerator</span><span class="o">(</span><span class="nc">ReapingCycle</span><span class="o">)</span>
</pre></div>
</div>
<p>This expression constructs a single <tt class="docutils literal"><span class="pre">PipelineStage</span></tt> instance from 3 to 7 sub-stages, depending on the configuration
settings of the client. The lines containing a <tt class="docutils literal"><span class="pre">?</span></tt> operator evaluate to <tt class="docutils literal"><span class="pre">EmptyPipelineStage</span></tt> if the boolean
expression before the <tt class="docutils literal"><span class="pre">?</span></tt> is false. The <tt class="docutils literal"><span class="pre">EmptyPipelineStage</span></tt> singleton object serves as a “neutral” element when
combining pipeline stages. Its <tt class="docutils literal"><span class="pre">build</span></tt> method doesn’t append any logic to either pipeline, so “switched off”
PipelineStages do not introduce any overhead.</p>
</div>
<div id="the-final-stages" class="section">
<h2>The Final Stages</h2>
<p>Both pipelines, the command as well as the event pipeline, are always terminated by stages provided by the connection
actor itself. The following, an excerpt of the <a href="https://github.com/spray/spray/blob/master/spray-io/src/main/scala/spray/io/ConnectionActors.scala" class="reference external">IOConnectionActor sources</a>, is their definition:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">def</span> <span class="n">baseCommandPipeline</span><span class="k">:</span> <span class="kt">Pipeline</span><span class="o">[</span><span class="kt">Command</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">IOPeer</span><span class="o">.</span><span class="nc">Send</span><span class="o">(</span><span class="n">buffers</span><span class="o">,</span> <span class="n">ack</span><span class="o">)</span>          <span class="k">=&gt;</span> <span class="n">ioBridge</span> <span class="o">!</span> <span class="nc">IOBridge</span><span class="o">.</span><span class="nc">Send</span><span class="o">(</span><span class="n">connection</span><span class="o">,</span> <span class="n">buffers</span><span class="o">,</span> <span class="n">eventize</span><span class="o">(</span><span class="n">ack</span><span class="o">))</span>
  <span class="k">case</span> <span class="nc">IOPeer</span><span class="o">.</span><span class="nc">Close</span><span class="o">(</span><span class="n">reason</span><span class="o">)</span>               <span class="k">=&gt;</span> <span class="n">ioBridge</span> <span class="o">!</span> <span class="nc">IOBridge</span><span class="o">.</span><span class="nc">Close</span><span class="o">(</span><span class="n">connection</span><span class="o">,</span> <span class="n">reason</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">IOPeer</span><span class="o">.</span><span class="nc">StopReading</span>                 <span class="k">=&gt;</span> <span class="n">ioBridge</span> <span class="o">!</span> <span class="nc">IOBridge</span><span class="o">.</span><span class="nc">StopReading</span><span class="o">(</span><span class="n">connection</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">IOPeer</span><span class="o">.</span><span class="nc">ResumeReading</span>               <span class="k">=&gt;</span> <span class="n">ioBridge</span> <span class="o">!</span> <span class="nc">IOBridge</span><span class="o">.</span><span class="nc">ResumeReading</span><span class="o">(</span><span class="n">connection</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">IOPeer</span><span class="o">.</span><span class="nc">Tell</span><span class="o">(</span><span class="n">receiver</span><span class="o">,</span> <span class="n">msg</span><span class="o">,</span> <span class="n">sender</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">receiver</span><span class="o">.</span><span class="n">tell</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="n">sender</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">Droppable</span> <span class="o">=&gt;</span> <span class="c1">// don't warn</span>
  <span class="k">case</span> <span class="n">cmd</span> <span class="k">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="o">(</span><span class="s">"commandPipeline: dropped {}"</span><span class="o">,</span> <span class="n">cmd</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">baseEventPipeline</span><span class="k">:</span> <span class="kt">Pipeline</span><span class="o">[</span><span class="kt">Event</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">IOPeer.Closed</span> <span class="o">=&gt;</span> <span class="n">stop</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">Droppable</span> <span class="o">=&gt;</span> <span class="c1">// don't warn</span>
  <span class="k">case</span> <span class="n">ev</span> <span class="k">=&gt;</span> <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="o">(</span><span class="s">"eventPipeline: dropped {}"</span><span class="o">,</span> <span class="n">ev</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The final stage of the command pipeline translates most of the defined messages into their <tt class="docutils literal"><span class="pre">IOBridge</span></tt> counterparts
and sends them off to the bridge. There is one command, <tt class="docutils literal"><span class="pre">IOPeer.Tell</span></tt>, which does not follow this pattern.
This command simply encapsulates an Actor <tt class="docutils literal"><span class="pre">tell</span></tt> call into a <tt class="docutils literal"><span class="pre">Command</span></tt> message. Whenever a pipeline stage would like
to send a message to an actor it should push an <tt class="docutils literal"><span class="pre">IOPeer.Tell</span></tt> command into the command pipeline rather than
calling <tt class="docutils literal"><span class="pre">actorRef.tell</span></tt> directly. This design has two benefits:</p>
<ul class="simple">
<li>Other downstream pipeline stages can react to, and maybe even modify the <tt class="docutils literal"><span class="pre">Tell</span></tt>.</li>
<li>The stage remains independently testable, without the need to fire up actors. (Check out the <a href="../testing-pipelines/#testing-pipelines" class="reference internal"><em>Testing Pipelines</em></a>
chapter for more info on this.)</li>
</ul>
<p>The final stage of the event pipeline only reacts to <tt class="docutils literal"><span class="pre">Closed</span></tt> messages. It stops the connection actor as a result.</p>
</div>
</div>
<div id="predefined-stages" class="section">
<h1>Predefined Stages</h1>
<p><em>spray-io</em> comes with a number of predefined pipeline stages, which you can “bake into” your own pipeline stack, where
you seem fit.</p>
<div id="tickgenerator" class="section">
<span id="id1"></span><h2>TickGenerator</h2>
<p>The <a href="https://github.com/spray/spray/blob/master/spray-io/src/main/scala/spray/io/TickGenerator.scala" class="reference external">TickGenerator</a> forms a simple <tt class="docutils literal"><span class="pre">event-only</span> <span class="pre">stage</span></tt> that generates <tt class="docutils literal"><span class="pre">Tick</span></tt> events in regular intervals.
This is its implementation:</p>
<blockquote>
<div></div></blockquote>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">object</span> <span class="nc">TickGenerator</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">millis</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">PipelineStage</span> <span class="o">=</span> <span class="n">apply</span><span class="o">(</span><span class="nc">Duration</span><span class="o">(</span><span class="n">millis</span><span class="o">,</span> <span class="nc">MILLISECONDS</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">period</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">PipelineStage</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="n">period</span> <span class="o">&gt;</span> <span class="nc">Duration</span><span class="o">.</span><span class="nc">Zero</span><span class="o">,</span> <span class="s">"period must be positive"</span><span class="o">)</span>

    <span class="k">new</span> <span class="nc">PipelineStage</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">build</span><span class="o">(</span><span class="n">context</span><span class="k">:</span> <span class="kt">PipelineContext</span><span class="o">,</span> <span class="n">commandPL</span><span class="k">:</span> <span class="kt">CPL</span><span class="o">,</span> <span class="n">eventPL</span><span class="k">:</span> <span class="kt">EPL</span><span class="o">)</span><span class="k">:</span> <span class="kt">Pipelines</span> <span class="o">=</span>
        <span class="k">new</span> <span class="nc">Pipelines</span> <span class="o">{</span>
          <span class="k">val</span> <span class="n">generator</span> <span class="k">=</span> <span class="o">{</span>
            <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">connectionActorContext</span><span class="o">.</span><span class="n">system</span>
            <span class="n">system</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">schedule</span><span class="o">(</span>
              <span class="n">initialDelay</span> <span class="k">=</span> <span class="n">period</span><span class="o">,</span>
              <span class="n">interval</span> <span class="k">=</span> <span class="n">period</span><span class="o">,</span>
              <span class="n">receiver</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">self</span><span class="o">,</span>
              <span class="n">message</span> <span class="k">=</span> <span class="nc">Tick</span>
            <span class="o">)(</span><span class="n">system</span><span class="o">.</span><span class="n">dispatcher</span><span class="o">)</span>
          <span class="o">}</span>

          <span class="k">val</span> <span class="n">commandPipeline</span> <span class="k">=</span> <span class="n">commandPL</span>

          <span class="k">val</span> <span class="n">eventPipeline</span><span class="k">:</span> <span class="kt">EPL</span> <span class="o">=</span> <span class="o">{</span>
            <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">IOPeer.Closed</span> <span class="o">=&gt;</span>
              <span class="n">generator</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>
              <span class="n">eventPL</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
            <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">eventPL</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
          <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">////////////// COMMANDS //////////////</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Tick</span> <span class="k">extends</span> <span class="nc">Event</span> <span class="k">with</span> <span class="nc">Droppable</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">TickGenerator</span></tt> provides the triggers for all timeout checking stages in <em>spray-io</em> and <a href="../../spray-can/#spray-can" class="reference internal"><em>spray-can</em></a>, but, of
course, you can also use it for other purposes.</p>
</div>
<div id="connectiontimeouts" class="section">
<span id="id3"></span><h2>ConnectionTimeouts</h2>
<p>The <a href="https://github.com/spray/spray/blob/master/spray-io/src/main/scala/spray/io/ConnectionTimeouts.scala" class="reference external">ConnectionTimeouts</a> pipeline stage provides support for the automatic closing of idle connection after a
configurable time period. The stage is modeled as a <tt class="docutils literal"><span class="pre">full</span> <span class="pre">stage</span></tt> that listens for outgoing <tt class="docutils literal"><span class="pre">Send</span></tt> commands
as well as incoming <tt class="docutils literal"><span class="pre">Received</span></tt> events and updates a <tt class="docutils literal"><span class="pre">lastActivity</span></tt> timestamp, whenever it sees one such message.</p>
<p>It requires a <a href="#tickgenerator" class="reference internal">TickGenerator</a> stage further down in the stack and uses its <tt class="docutils literal"><span class="pre">Tick</span></tt> messages as a trigger for checking,
whether the connection has been idle for longer than the allowed time frame. If so, a <tt class="docutils literal"><span class="pre">Close</span></tt> command is issued.</p>
</div>
<div id="ssltlssupport" class="section">
<h2>SslTlsSupport</h2>
<p>The <a href="https://github.com/spray/spray/blob/master/spray-io/src/main/scala/spray/io/SslTlsSupport.scala" class="reference external">SslTlsSupport</a> pipeline stage provides for transparent encryption of outgoing <tt class="docutils literal"><span class="pre">Send</span></tt> commands as well as
decryption of incoming <tt class="docutils literal"><span class="pre">Received</span></tt> commands. Just add it as a lower-level stage to your pipeline stack, whenever you
need SSL/TLS encryption, and all your network communication can be SSL encrypted automatically.</p>
<p>The <tt class="docutils literal"><span class="pre">SslTlsSupport</span></tt> also allows for the enabling/disabling of the encryption stage on a per-connection basis.
This is controlled via the connection “tag”, check the <a href="../connection-tags/#connection-tags" class="reference internal"><em>Connection Tags</em></a> chapter for more info on this.
If the connection tag does not implement the <tt class="docutils literal"><span class="pre">SslTlsSupport.Enabling</span></tt> trait the decision, whether to encrypt the
connection or not, is determined via the <tt class="docutils literal"><span class="pre">encryptIfUntagged</span></tt> parameter specified at pipeline stage creation.</p>
<p>The <tt class="docutils literal"><span class="pre">SslTlsSupport</span></tt> stage requires also requires an <tt class="docutils literal"><span class="pre">engineProvider</span></tt> parameter, which is a function
<tt class="docutils literal"><span class="pre">PipelineContext</span> <span class="pre">=&gt;</span> <span class="pre">SSLEngine</span></tt>. The easiest way to specify an argument for this parameter is to use the default
<tt class="docutils literal"><span class="pre">ServerSSLEngineProvider</span></tt> or <tt class="docutils literal"><span class="pre">ClientSSLEngineProvider</span></tt>, depending on whether you are using the encryption stage
on the client- or the server-side, e.g.:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">engineProvider</span> <span class="k">=</span> <span class="nc">ServerSSLEngineProvider</span><span class="o">.</span><span class="n">default</span>
</pre></div>
</div>
<p>In order to make this line compile you also need to bring into scope either an implicit <tt class="docutils literal"><span class="pre">javax.net.ssl.SSLContext</span></tt>
or an implicit <tt class="docutils literal"><span class="pre">SSLContextProvider</span></tt>.</p>
</div>
</div>
<div id="connection-tags" class="section">
<span id="id1"></span><h1>Connection Tags</h1>
<p>Every connection (handle) has a custom <tt class="docutils literal"><span class="pre">tag:</span> <span class="pre">Any</span></tt> member that it initially receives from the command that triggered
the connection, which is either the <tt class="docutils literal"><span class="pre">Bind</span></tt> for server-side or <tt class="docutils literal"><span class="pre">Connect</span></tt> for client-side connections.</p>
<p>Additionally the connection tag can be changed right before a new handle is registered by overriding the
<tt class="docutils literal"><span class="pre">connectionTag</span></tt> method (from the <tt class="docutils literal"><span class="pre">ConnectionActors</span></tt> trait), which is especially useful for servers that would like
to attach individual tags to accepted connections and not use (the same) <tt class="docutils literal"><span class="pre">Bind</span></tt> tag for all of them.</p>
<p>Currently there are three uses for connection tags:</p>
<ol class="arabic">
<li><p class="first">Enable/disable encryption on a per-connection basis by having the tag object implement the <tt class="docutils literal"><span class="pre">SslTlsSupport.Enabling</span></tt>
trait:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * Interface that can be implemented by a `tag` object on the connection</span>
<span class="cm"> * in order to determine whether encryption on the connection is to be</span>
<span class="cm"> * enabled or not.</span>
<span class="cm"> */</span>
<span class="k">trait</span> <span class="nc">Enabling</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">encrypt</span><span class="o">(</span><span class="n">ctx</span><span class="k">:</span> <span class="kt">PipelineContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="o">}</span>
</pre></div>
</div>
<p>If the tag does not implement this trait the default setting applies, which is specified as an argument to the
<tt class="docutils literal"><span class="pre">SslTlsSupport</span></tt> pipeline stage creator. (For example, the <em>spray-can</em> <a href="../../spray-can/http-client/#httpclient" class="reference internal"><em>HttpClient</em></a> has a default of
“not encrypted” and the <em>spray-can</em> <a href="../../spray-can/http-server/#httpserver" class="reference internal"><em>HttpServer</em></a> a default of “encrypted”, when the
<tt class="docutils literal"><span class="pre">spray.can.server.ssl-encryption</span></tt> config setting is enabled and <tt class="docutils literal"><span class="pre">SslTlsSupport</span></tt> available.)</p>
</li>
<li><p class="first">Enable log marking: If the tag object implements the new <tt class="docutils literal"><span class="pre">spray.io.LogMarking</span></tt> trait all log messages produced by
the <em>spray-io</em> and <em>spray-can</em> layers for this connection will be prefixed with the respective log marker string.
This allows for easy grepping of all log messages related to a specific connection across all layers, even in massive
logs. The respective log logic is also accessible for your custom layers on top of <em>spray-io</em> / <em>spray-can</em> via the
<tt class="docutils literal"><span class="pre">spray.io.TaggableLog</span></tt> facility.</p>
</li>
<li><p class="first">Custom uses: Since your code has access to the tag from everywhere, including custom pipeline stages, tags can be
used as a channel for any kind of custom data needs.</p>
</li>
</ol>
</div>
<div id="testing-pipelines" class="section">
<span id="id1"></span><h1>Testing Pipelines</h1>
<p>Besides the architectural cleanliness a nice side effect of <em>spray-ios</em> <a href="../pipelining/#pipelining" class="reference internal"><em>Pipelining</em></a> architecture is that you can test
individual pipeline stages, or complete stacks of them, easily and without the need to fire up actors.</p>
<p><em>spray-io</em> comes with the <a href="https://github.com/spray/spray/blob/master/spray-io/src/main/scala/spray/io/PipelineStageTest.scala" class="reference external">PipelineStageTest</a> trait, which you can mix into any test specification. It gives you a
small DSL that allows for convenient testing of a pipeline stage (which can also be a combination of sub stages).</p>
<p>As an example you might want to take a look at the <a href="https://github.com/spray/spray/blob/master/spray-io/src/test/scala/spray/io/ConnectionTimeoutsSpec.scala" class="reference external">ConnectionTimeoutsSpec</a>, which tests the <a href="../predefined-stages/#connectiontimeouts" class="reference internal"><em>ConnectionTimeouts</em></a>
pipeline stage.</p>
<div id="overview" class="section">
<h2>Overview</h2>
<p>The <tt class="docutils literal"><span class="pre">PipelineStageTest</span></tt> trait contains a “pimp” for <tt class="docutils literal"><span class="pre">PipelineStage</span></tt> instances, which gives you a <tt class="docutils literal"><span class="pre">test</span></tt> method
taking a body of test code:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">stage</span><span class="k">:</span> <span class="kt">PipelineStage</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">stage</span><span class="o">.</span><span class="n">test</span> <span class="o">{</span>
  <span class="o">...</span> <span class="c1">// test code</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The code running “inside” of the <tt class="docutils literal"><span class="pre">test</span></tt> method has access to a number of helpers allowing for pushing commands and
events through the pipeline stage and inspecting the produced messages.</p>
</div>
<div id="process" class="section">
<h2>Process</h2>
<p>The most important helper is <tt class="docutils literal"><span class="pre">process</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">def</span> <span class="n">process</span><span class="o">(</span><span class="n">cmdsAndEvents</span><span class="k">:</span> <span class="kt">AnyRef*</span><span class="o">)</span><span class="k">:</span> <span class="kt">ProcessResult</span> <span class="o">=</span>
</pre></div>
</div>
<p>It allows you to push a number of commands and/or events into the respective ends of the pipeline stage and collect
the commands and events produced by the stage:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">stage</span><span class="k">:</span> <span class="kt">PipelineStage</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">stage</span><span class="o">.</span><span class="n">test</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">process</span><span class="o">(</span><span class="nc">MyCommand</span><span class="o">,</span> <span class="nc">MyEvent</span><span class="o">)</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The result produced by the <tt class="docutils literal"><span class="pre">process</span></tt> method is an instance of <tt class="docutils literal"><span class="pre">ProcessResult</span></tt>, which is defined as such:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">ProcessResult</span><span class="o">(</span><span class="n">commands</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Command</span><span class="o">],</span> <span class="n">events</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Event</span><span class="o">])</span>
</pre></div>
</div>
<p>It contains a “snapshot” of the current state of the internal message collector. If you call <tt class="docutils literal"><span class="pre">process</span></tt> several times
the collected messages will accumulate. So, this snippet:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">process</span><span class="o">(</span><span class="nc">MyCommand</span><span class="o">)</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">process</span><span class="o">(</span><span class="nc">MyEvent</span><span class="o">)</span>
</pre></div>
</div>
<p>is equivalent to this one:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">process</span><span class="o">(</span><span class="nc">MyCommand</span><span class="o">,</span> <span class="nc">MyEvent</span><span class="o">)</span>
</pre></div>
</div>
<p>You can clear the message collector with <tt class="docutils literal"><span class="pre">clear()</span></tt>. Also there are two variants of <tt class="docutils literal"><span class="pre">process</span></tt>, which combine it with
a <tt class="docutils literal"><span class="pre">clear()</span></tt>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">def</span> <span class="n">clearAndProcess</span><span class="o">(</span><span class="n">cmdsAndEvents</span><span class="k">:</span> <span class="kt">AnyRef*</span><span class="o">)</span><span class="k">:</span> <span class="kt">ProcessResult</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">clear</span><span class="o">()</span>
  <span class="n">process</span><span class="o">(</span><span class="n">cmdsAndEvents</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">processAndClear</span><span class="o">(</span><span class="n">cmdsAndEvents</span><span class="k">:</span> <span class="kt">AnyRef*</span><span class="o">)</span><span class="k">:</span> <span class="kt">ProcessResult</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">process</span><span class="o">(</span><span class="n">cmdsAndEvents</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span>
  <span class="n">clear</span><span class="o">()</span>
  <span class="n">x</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div id="extractors" class="section">
<h2>Extractors</h2>
<p>Once you have a <tt class="docutils literal"><span class="pre">ProcessResult</span></tt> instance you could “manually” inspect it and express assertions against its contents
using the constructs of your test framework. For example, using <a href="http://specs2.org" class="reference external">specs2</a>, you might say something like this:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">stage</span><span class="k">:</span> <span class="kt">PipelineStage</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">stage</span><span class="o">.</span><span class="n">test</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">process</span><span class="o">(</span><span class="nc">MyCommand</span><span class="o">,</span> <span class="nc">MyEvent</span><span class="o">)</span>
  <span class="n">result</span><span class="o">.</span><span class="n">commands</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">===</span> <span class="nc">MyFirstExpectedCommand</span>
  <span class="n">result</span><span class="o">.</span><span class="n">commands</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">===</span> <span class="nc">MySecondExpectedCommand</span>
<span class="o">}</span>
</pre></div>
</div>
<p>However, this manual decomposition of the <tt class="docutils literal"><span class="pre">ProcessResult</span></tt> can become tedious for more complex checks.
Using the simple <tt class="docutils literal"><span class="pre">Commands</span></tt> extractor that the <tt class="docutils literal"><span class="pre">PipelineStageTest</span></tt> trait provides the test becomes a bit better to
read:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="n">stage</span><span class="k">:</span> <span class="kt">PipelineStage</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">stage</span><span class="o">.</span><span class="n">test</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">Commands</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">second</span><span class="o">)</span> <span class="k">=</span> <span class="n">process</span><span class="o">(</span><span class="nc">MyCommand</span><span class="o">,</span> <span class="nc">MyEvent</span><span class="o">)</span>
  <span class="n">first</span> <span class="o">===</span> <span class="nc">MyFirstExpectedCommand</span>
  <span class="n">second</span> <span class="o">===</span> <span class="nc">MySecondExpectedCommand</span>
<span class="o">}</span>
</pre></div>
</div>
<p>There is also an <tt class="docutils literal"><span class="pre">Events</span></tt> extractor that allows you to pattern match against the collected event messages.</p>
</div>
<div id="message-conditioning" class="section">
<h2>Message Conditioning</h2>
<p>Writing tests using <tt class="docutils literal"><span class="pre">Send</span></tt> commands and <tt class="docutils literal"><span class="pre">Received</span></tt> messages can be a bit inconvenient, since both of them carry
their content in binary form as byte arrays wrapped by a <tt class="docutils literal"><span class="pre">java.nio.ByteBuffer</span></tt>. To simplify test code the
<tt class="docutils literal"><span class="pre">PipelineStageTest</span></tt> therefore automatically converts <tt class="docutils literal"><span class="pre">Send</span></tt> commands into <tt class="docutils literal"><span class="pre">SendString</span></tt> commands, which allow
you directly test against String literals:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">val</span> <span class="nc">Commands</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span> <span class="k">=</span> <span class="n">process</span><span class="o">(...)</span>
<span class="n">msg</span> <span class="o">===</span> <span class="nc">SendString</span><span class="o">(</span><span class="s">"expected content"</span><span class="o">)</span>
</pre></div>
</div>
<p>The same is done on the event-side to <tt class="docutils literal"><span class="pre">Received</span></tt> events, which are automatically converted to <tt class="docutils literal"><span class="pre">ReceivedString</span></tt>
events.</p>
<p>Additionally the <tt class="docutils literal"><span class="pre">PipelineStageTest</span></tt> trait provides helpers to create <tt class="docutils literal"><span class="pre">Send</span></tt> and <tt class="docutils literal"><span class="pre">Received</span></tt> commands directly
from strings:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">process</span><span class="o">(</span><span class="nc">Received</span><span class="o">(</span><span class="s">"received content"</span><span class="o">),</span> <span class="nc">Send</span><span class="o">(</span><span class="s">"sent content"</span><span class="o">))</span>
</pre></div>
</div>
</div>
<div id="messages-to-and-from-actors" class="section">
<h2>Messages to and from Actors</h2>
<p>Sometimes pipelines stage logic needs to use the <tt class="docutils literal"><span class="pre">sender</span></tt> reference of an incoming message. In order to simulate the
reception of a message from a specific sender the <tt class="docutils literal"><span class="pre">PipelineStageTest</span></tt> provides the <tt class="docutils literal"><span class="pre">Message</span></tt> type:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">Message</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">,</span> <span class="n">sender</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span>
</pre></div>
</div>
<p>For example, to feed the pipeline stage with a <tt class="docutils literal"><span class="pre">Send</span></tt> command sent by <tt class="docutils literal"><span class="pre">sender1</span></tt> you would say:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">process</span><span class="o">(</span><span class="nc">Message</span><span class="o">(</span><span class="nc">Send</span><span class="o">(</span><span class="s">"sent content"</span><span class="o">),</span> <span class="n">sender1</span><span class="o">))</span>
</pre></div>
</div>
<p>In order to be able to verify that a pipeline stage sends the expected messages to other actors all pipeline stages
should use the <tt class="docutils literal"><span class="pre">IOPeer.Tell</span></tt> command, rather than sending the message directly. Not only does this allow you to treat
message sending like any other command (and verify it using the techniques explained above), it also allows other
downstream stages in the command pipeline to see the <tt class="docutils literal"><span class="pre">Tell</span></tt> and potentially modify or react to it.</p>
</div>
</div>
<div id="examples" class="section">
<h1>Examples</h1>
<p>The <tt class="docutils literal"><span class="pre">/examples/spray-io/</span></tt> directory of the <em>spray</em> repository
contains a number of example projects for <em>spray-io</em>, which are described here.</p>
<div id="echo-server" class="section">
<h2>echo-server</h2>
<p>This example demonstrates how you can create a very simple network server with <em>spray-io</em>.</p>
<p>Follow these steps to run it on your machine:</p>
<ol class="arabic">
<li><p class="first">Clone the <em>spray</em> repository:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">git</span> <span class="n">clone</span> <span class="n">git</span><span class="o">://</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">spray</span><span class="o">/</span><span class="n">spray</span><span class="o">.</span><span class="n">git</span>
</pre></div>
</div>
</li>
<li><p class="first">Change into the base directory:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">cd</span> <span class="n">spray</span>
</pre></div>
</div>
</li>
<li><p class="first">Run SBT:</p>
<div class="highlight-scala"><div class="highlight"><pre><span class="n">sbt</span> <span class="s">"project echo-server"</span> <span class="n">run</span>
</pre></div>
</div>
<p>(If this doesn’t work for you your SBT runner cannot deal with grouped arguments. In this case you’ll have to
run the commands <tt class="docutils literal"><span class="pre">project</span> <span class="pre">echo-server</span></tt> and <tt class="docutils literal"><span class="pre">run</span></tt> sequentially “inside” of SBT.)</p>
</li>
<li><p class="first">Run <tt class="docutils literal"><span class="pre">telnet</span> <span class="pre">localhost</span> <span class="pre">23456</span></tt>, type something and press RETURN</p>
</li>
<li><p class="first">Type <tt class="docutils literal"><span class="pre">STOP</span></tt> to exit</p>
</li>
</ol>
</div>
</div>