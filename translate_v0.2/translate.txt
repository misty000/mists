<div>
<h1 data-translate="依赖" class="">Dependencies</h1>
<p data-translate="除了Scala库（见Current Version(s)章节），spray-io仅依赖于spray-util和akka-actor（用'provided'作用域，即你需要自己添加它）。" class="">Apart from the Scala library (see <a href="javascript://"><em>Current Version(s)</em></a> chapter) <em>spray-io</em> only depends on <a href="javascript://"><em>spray-util</em></a> and
<em>akka-actor</em> (with ‘provided’ scope, i.e. you need to pull it in yourself).</p>
</div>
<div>
<h1 data-translate="安装" class="">Installation</h1>
<p data-translate="Maven仓库章节包含关于如何抽取spray-io到你的类路径的所有信息。" class="">The <a href="javascript://"><em>Maven Repository</em></a> chapter contains all the info about how to pull <em>spray-io</em> into your classpath.</p>
<p data-translate="然后仅需要用import spray.io._将所有相关标识符引入作用域。" class="">Afterwards just <tt><span>import</span> <span>spray.io._</span></tt> to bring all relevant identifiers into scope.</p>
</div>
<div>
<h1 data-translate="配置" class="">Configuration</h1>
<p>Just like Akka <em>spray-io</em> relies on the <a href="javascript://">typesafe config</a> library for configuration. As such its JAR contains a
<tt><span>reference.conf</span></tt> file holding the default values of all configuration settings. In your application you typically
provide an <tt><span>application.conf</span></tt>, in which you override Akka and/or <em>spray</em> settings according to your needs.</p>
<div>
<p>Note</p>
<p>Since <em>spray</em> uses the same configuration technique as Akka you might want to check out the
<a href="javascript://">Akka Documentation on Configuration</a>.</p>
</div>
<p>This is the <tt><span>reference.conf</span></tt> of the <em>spray-io</em> module:</p>
<div><div><pre><span>##################################</span>
<span># spray-io Reference Config File #</span>
<span>##################################</span>

<span># This is the reference config file that contains all the default settings.</span>
<span># Make your edits/overrides in your application.conf.</span>

spray.io <span>{</span>

  <span># the number of threads to spread connection management across</span>
  <span># 1     = the root IOBridge manages all sockets itself (a good default for most applications)</span>
  <span># n &gt; 1 = the root IOBridge only handles ServerSockets for accepting new connections,</span>
  <span>#         mgmt. of the connection sockets themselves is spread equally across n sub-bridges</span>
  <span>parallelism</span> <span>=</span> 1

  <span># the size of the buffer to allocate (anew!) for every read from a socket</span>
  <span>read</span>-buffer-size <span>=</span> 4k

  tcp <span>{</span>
    <span># value for the SO_RCVBUF option for the created TCP sockets,</span>
    <span># set to zero to not explicitly set a value but use the default</span>
    receive-buffer-size <span>=</span> 0

    <span># value for the SO_SNDBUF option for the created TCP sockets,</span>
    <span># set to zero to not explicitly set a value but use the default</span>
    send-buffer-size <span>=</span> 0

    <span># indicates whether SO_KEEPALIVE should be set for the created TCP sockets,</span>
    <span># 0 -&gt; default, 1 -&gt; true, -1 -&gt; false</span>
    keep-alive <span>=</span> 0

    <span># indicates whether TCP_NODELAY should be set for the created TCP sockets,</span>
    <span># 0 -&gt; default, 1 -&gt; disable Nagle's algorithm, -1 -&gt; enable Nagle's algorithm</span>
    no-delay <span>=</span> 0
  <span>}</span>

  <span># the dispatcher for IOBridges, no flexibility here</span>
  io-bridge-dispatcher <span>=</span> <span>{</span>
    <span>type</span> <span>=</span> <span>"akka.spray.io.IOBridgeDispatcherConfigurator"</span>
  <span>}</span>
<span>}</span>
</pre></div>
</div>
</div>
<div>
<span></span><h1>IOBridge</h1>
<p>The <tt><span>IOBridge</span></tt> is the central and lowest-level component of <em>spray-io</em>. It provides a thin and efficient
“adapter layer” between the network (i.e. sockets) and Akka actors.</p>
<p>There are two sides to this “adapter layer”:</p>
<dl>
<dt>Outgoing network “commands”</dt>
<dd>Command messages coming in from the application, like “connect to a certain address”, “write this series of bytes” or
“close the connection” are applied to the respective connection/socket.</dd>
<dt>Incoming network “events”</dt>
<dd>Everything that happens on a socket managed by an <tt><span>IOBridge</span></tt>, like the acceptance of a new connection, the reading
of a series of bytes or the closing of the connection, is packaged in a respective event message and sent to
a “handler” actor responsible for the connection.</dd>
</dl>
<p>An <tt><span>IOBridge</span></tt> is implemented as an Akka actor using a special dispatcher, which allows it to “own” one private
thread, from which it manages one Java NIO selector. An <tt><span>IOBridge</span></tt> can easily handle many thousand connections, which
can be any mix of incoming and outgoing (i.e. server- and client-side) connections.</p>
<div>
<h2>Parallelism</h2>
<p>Depending on the <tt><span>parallelism</span></tt> config setting there will either only be one single <tt><span>IOBridge</span></tt> actor per
<tt><span>ActorSystem</span></tt> (<tt><span>parallellism</span> <span>=</span> <span>1</span></tt>, the default) or several ones. For many applications a single <tt><span>IOBridge</span></tt> is
perfectly capable of handling all network IO load. However, if you have a very IO-intensive application it might make
sense to distribute IO-handling across several threads. In these cases you can increase the <tt><span>parallelism</span></tt> setting
to values like 4 or 8, which causes the root <tt><span>IOBridge</span></tt> actor to only handle connection establishment itself and
distribute management of the individual connections equally across 4 or 8 “sub-bridge” actors, which are automatically
spawned.</p>
</div>
<div>
<h2>Lifecycle</h2>
<p>Every <tt><span>ActorSystem</span></tt> can only contain a single (root) <tt><span>IOBridge</span></tt> that you create via the <tt><span>ioBridge</span></tt> method of
<em>sprays</em> <tt><span>IOExtension</span></tt>. Subsequent calls to this method will not create new instances but return the existing (root)
one.</p>
<div><div><pre><span>import</span> <span>akka.actor.ActorSystem</span>
<span>import</span> <span>spray.io.IOExtension</span>

<span>val</span> <span>system</span> <span>=</span> <span>ActorSystem</span><span>()</span>

<span>val</span> <span>ioBridge</span> <span>=</span> <span>IOExtension</span><span>(</span><span>system</span><span>).</span><span>ioBridge</span><span>()</span>

<span>// start applications actors using the ioBridge instance</span>
<span>// ...</span>
</pre></div>
</div>
<p>Since an <tt><span>IOBridge</span></tt> is a regular Akka actor all commmunication with it happens asynchronously through messages,
which can be either of type <tt><span>Command</span></tt> or <tt><span>Event</span></tt>.</p>
</div>
<div>
<h2>Commands</h2>
<p>Once you have an <tt><span>IOBridge</span></tt> instance you’ll want to send commands to it.
These are all the defined commands:</p>
<div><div><pre><span>// general commands not on the connection-level</span>
<span>case</span> <span>class</span> <span>Bind</span><span>(</span><span>address</span><span>:</span> <span>InetSocketAddress</span><span>,</span> <span>backlog</span><span>:</span> <span>Int</span><span>,</span> <span>tag</span><span>:</span> <span>Any</span> <span>=</span> <span>())</span> <span>extends</span> <span>Command</span>
<span>case</span> <span>class</span> <span>Unbind</span><span>(</span><span>bindingKey</span><span>:</span> <span>Key</span><span>)</span> <span>extends</span> <span>Command</span>
<span>case</span> <span>class</span> <span>Connect</span><span>(</span><span>remoteAddress</span><span>:</span> <span>InetSocketAddress</span><span>,</span>
                   <span>localAddress</span><span>:</span> <span>Option</span><span>[</span><span>InetSocketAddress</span><span>]</span> <span>=</span> <span>None</span><span>,</span>
                   <span>tag</span><span>:</span> <span>Any</span> <span>=</span> <span>())</span> <span>extends</span> <span>Command</span>
<span>object</span> <span>Connect</span> <span>{</span>
  <span>def</span> <span>apply</span><span>(</span><span>host</span><span>:</span> <span>String</span><span>,</span> <span>port</span><span>:</span> <span>Int</span><span>)</span><span>:</span> <span>Connect</span> <span>=</span> <span>apply</span><span>(</span><span>host</span><span>,</span> <span>port</span><span>,</span> <span>())</span>
  <span>def</span> <span>apply</span><span>(</span><span>host</span><span>:</span> <span>String</span><span>,</span> <span>port</span><span>:</span> <span>Int</span><span>,</span> <span>tag</span><span>:</span> <span>Any</span><span>)</span><span>:</span> <span>Connect</span> <span>=</span>
    <span>Connect</span><span>(</span><span>new</span> <span>InetSocketAddress</span><span>(</span><span>host</span><span>,</span> <span>port</span><span>),</span> <span>None</span><span>,</span> <span>tag</span><span>)</span>
<span>}</span>
<span>case</span> <span>object</span> <span>GetStats</span> <span>extends</span> <span>Command</span>

<span>// connection-level commands</span>
<span>trait</span> <span>ConnectionCommand</span> <span>extends</span> <span>Command</span> <span>{</span>
  <span>def</span> <span>handle</span><span>:</span> <span>Handle</span>
<span>}</span>
<span>case</span> <span>class</span> <span>Register</span><span>(</span><span>handle</span><span>:</span> <span>Handle</span><span>)</span> <span>extends</span> <span>ConnectionCommand</span>
<span>case</span> <span>class</span> <span>Close</span><span>(</span><span>handle</span><span>:</span> <span>Handle</span><span>,</span>
                 <span>reason</span><span>:</span> <span>CloseCommandReason</span><span>)</span> <span>extends</span> <span>ConnectionCommand</span>
<span>case</span> <span>class</span> <span>Send</span><span>(</span><span>handle</span><span>:</span> <span>Handle</span><span>,</span>
                <span>buffers</span><span>:</span> <span>Seq</span><span>[</span><span>ByteBuffer</span><span>],</span>
                <span>ack</span><span>:</span> <span>Option</span><span>[</span><span>Any</span><span>]</span> <span>=</span> <span>None</span><span>)</span> <span>extends</span> <span>ConnectionCommand</span>
<span>object</span> <span>Send</span> <span>{</span>
  <span>def</span> <span>apply</span><span>(</span><span>handle</span><span>:</span> <span>Handle</span><span>,</span> <span>buffer</span><span>:</span> <span>ByteBuffer</span><span>)</span><span>:</span> <span>Send</span> <span>=</span>
    <span>apply</span><span>(</span><span>handle</span><span>,</span> <span>buffer</span><span>,</span> <span>None</span><span>)</span>
  <span>def</span> <span>apply</span><span>(</span><span>handle</span><span>:</span> <span>Handle</span><span>,</span> <span>buffer</span><span>:</span> <span>ByteBuffer</span><span>,</span> <span>ack</span><span>:</span> <span>Option</span><span>[</span><span>Any</span><span>])</span><span>:</span> <span>Send</span> <span>=</span>
    <span>new</span> <span>Send</span><span>(</span><span>handle</span><span>,</span> <span>buffer</span> <span>::</span> <span>Nil</span><span>,</span> <span>ack</span><span>)</span>
<span>}</span>
<span>case</span> <span>class</span> <span>StopReading</span><span>(</span><span>handle</span><span>:</span> <span>Handle</span><span>)</span> <span>extends</span> <span>ConnectionCommand</span>
<span>case</span> <span>class</span> <span>ResumeReading</span><span>(</span><span>handle</span><span>:</span> <span>Handle</span><span>)</span> <span>extends</span> <span>ConnectionCommand</span>
</pre></div>
</div>
<p>And here is what action they instruct the bridge to perform:</p>
<dl>
<dt>Bind</dt>
<dd>Start listening for incoming connections on a particular port. The sender receives a <tt><span>Bound</span></tt> event upon completion
as well as <tt><span>Connected</span></tt> events for each new incoming connection that has been accepted.</dd>
<dt>Unbind</dt>
<dd>Revert a previous <tt><span>Bind</span></tt>. The sender receives an <tt><span>Unbound</span></tt> event upon completion.</dd>
<dt>Connect</dt>
<dd>Connect to remote address. The sender receives a <tt><span>Connected</span></tt> event upon completion.</dd>
<dt>GetStats</dt>
<dd>Send the sender an <tt><span>IOBridge.StatsMap</span></tt> message containing simple statistics for the root bridge and all potentially
existing sub-bridges.</dd>
<dt>Register</dt>
<dd>Register the given <tt><span>Handle</span></tt> that was newly created as a result of a <tt><span>Connected</span></tt> event and start accepting
incoming data on its connection.</dd>
<dt>Close</dt>
<dd>Close the connection of the given <tt><span>Handle</span></tt>. If there are pending <tt><span>Send</span></tt> commands that haven’t yet been completed
the closing is queued. Special case: If the <tt><span>reason</span></tt> is <tt><span>ConfirmedClose</span></tt> the socket is not closed right away, but
rather via a full TCP FIN message exchange is performed. I.e. at first a TCP FIN message is sent and the peers
“ack’ing” FIN is awaited before the socket is closed.
Independently of when the socket is actually closed the handler of the connection receives a <tt><span>Closed</span></tt> event after
it has happened.</dd>
<dt>Send</dt>
<dd>Write the contents of the given ByteBuffers to the socket associated with the given handle. If <tt><span>ack</span></tt> is defined the
sender receives its content as a “send confirmation” message when all bytes have been successfully written to the
socket.</dd>
<dt>StopReading</dt>
<dd>Stop accepting incoming data from the socket associated with the given handle.</dd>
<dt>ResumeReading</dt>
<dd>Resume accepting incoming data from the socket associated with the given handle.</dd>
</dl>
</div>
<div>
<h2>Events</h2>
<p>These are all the events that are generated by an <tt><span>IOBridge</span></tt> instance:</p>
<div><div><pre><span>// "general" events not on the connection-level</span>
<span>case</span> <span>class</span> <span>Bound</span><span>(</span><span>bindingKey</span><span>:</span> <span>Key</span><span>,</span> <span>tag</span><span>:</span> <span>Any</span><span>)</span> <span>extends</span> <span>Event</span>
<span>case</span> <span>class</span> <span>Unbound</span><span>(</span><span>bindingKey</span><span>:</span> <span>Key</span><span>,</span> <span>tag</span><span>:</span> <span>Any</span><span>)</span> <span>extends</span> <span>Event</span>
<span>case</span> <span>class</span> <span>Connected</span><span>(</span><span>key</span><span>:</span> <span>Key</span><span>,</span> <span>tag</span><span>:</span> <span>Any</span><span>)</span> <span>extends</span> <span>Event</span>

<span>// connection-level events</span>
<span>case</span> <span>class</span> <span>Closed</span><span>(</span><span>handle</span><span>:</span> <span>Handle</span><span>,</span> <span>reason</span><span>:</span> <span>ClosedEventReason</span><span>)</span> <span>extends</span> <span>Event</span> <span>with</span> <span>IOClosed</span>
<span>case</span> <span>class</span> <span>Received</span><span>(</span><span>handle</span><span>:</span> <span>Handle</span><span>,</span> <span>buffer</span><span>:</span> <span>ByteBuffer</span><span>)</span> <span>extends</span> <span>Event</span>
</pre></div>
</div>
<p>And these are their semantics:</p>
<dl>
<dt>Bound</dt>
<dd>Sent as confirmation to the sender of a preceding <tt><span>Bind</span></tt> command.</dd>
<dt>Unbound</dt>
<dd>Sent as confirmation to the sender of a preceding <tt><span>Unbind</span></tt> command.</dd>
<dt>Connected</dt>
<dd>Sent after a new connection has been established to the sender of a preceding <tt><span>Bind</span></tt> or <tt><span>Connect</span></tt> command.</dd>
<dt>Closed</dt>
<dd>Sent to the handler actor after a connection has been closed.</dd>
<dt>Received</dt>
<dd>Sent to the handler actor after a chunk of data has been read from the connections socket. Will never contain more
than the number of bytes configured as <tt><span>read-buffer-size</span></tt> in the <tt><span>IOBridgeSettings</span></tt>.</dd>
</dl>
</div>
<div>
<h2>Handle</h2>
<p>An <tt><span>IOBridge</span></tt> identifies connections using a “handle”, which can be any object implementing in the <tt><span>Handle</span></tt>
interface:</p>
<div><div><pre><span>trait</span> <span>Handle</span> <span>{</span>
  <span>/**</span>
<span>   * The key identifying the connection.</span>
<span>   */</span>
  <span>def</span> <span>key</span><span>:</span> <span>Key</span>

  <span>/**</span>
<span>   * The actor handling events coming in from the network.</span>
<span>   * If ConnectionActors are used this is the connection actor.</span>
<span>   */</span>
  <span>def</span> <span>handler</span><span>:</span> <span>ActorRef</span>

  <span>/**</span>
<span>   * A custom, application-defined tag object that can be attached</span>
<span>   * to a `Bind` or `Connect` command and is made available to the application</span>
<span>   * through the handle. Currently it is used for connection-specific</span>
<span>   * enabling/disabling of encryption (see `SslTlsSupport.Enabling` trait)</span>
<span>   * or for custom log marking (see `LogMarking` trait).</span>
<span>   */</span>
  <span>def</span> <span>tag</span><span>:</span> <span>Any</span>
<span>}</span>
</pre></div>
</div>
<p>The creation of actual handle instances is delegated to the user. This enables the lookup-free implementation of the
application logic, since all connection-specific event messages always carry the handle instance that was created by
the application and, as such, provide direct access to application data.</p>
<p>The typical pattern is that the application creates a new <tt><span>Handle</span></tt> instance after the reception of a <tt><span>Connected</span></tt>
event, which is the only way to get a hold of the required <tt><span>Key</span></tt> for the handle. After handle creation the application
then registers it with the <tt><span>IOBridge</span></tt> via a <tt><span>Register</span></tt> command.</p>
</div>
</div>
<div>
<span></span><h1>IOClient</h1>
<p>The <a href="javascript://">IOClient</a> is a simple actor base class for client-side networking components.
It builds upon an <a href="javascript://"><em>IOBridge</em></a> and provides client-side connection management. An <tt><span>IOClient</span></tt> cannot be used
directly but has to be subclassed (potentially mixing in the <a href="javascript://"><em>ConnectionActors</em></a> trait) and augmented
with the custom application logic that actually does whatever the specific networking client is supposed to do.
In that sense the <tt><span>IOClient</span></tt> class merely provides the “boilerplate” logic common to most <em>spray-io</em> based network
clients.</p>
<p>After having created an <tt><span>IOClient</span></tt> actor instance you typically send it a <tt><span>Connect</span></tt> message, which is either
responded to with a <tt><span>Connected</span></tt> event after the connection has been established, or a <tt><span>Status.Failure</span></tt> message
(which is automatically turned into Future failures, if the <tt><span>Connect</span></tt> was sent with an <tt><span>ask</span></tt>).</p>
<p>In its original form, without mixing in the <a href="javascript://"><em>ConnectionActors</em></a> trait, an <tt><span>IOClient</span></tt> designates itself as the
handler of all network events. You will therefore have to augment its <tt><span>receive</span></tt> behavior with your own logic
generating the appropriate <tt><span>Send</span></tt> commands as well as handling incoming <tt><span>Received</span></tt> events.</p>
<div>
<h2>Examples</h2>
<p>One example of a network client based on the <tt><span>IOClient</span></tt> is the <em>spray-can</em> <a href="javascript://"><em>HttpClient</em></a>. You might find
<a href="javascript://">its sources</a> quite readable.</p>
<p>Another (admittedly very contrived and overly simplified) example is presented here:</p>
<div><div><pre><span>import</span> <span>java.util.concurrent.TimeUnit._</span>
<span>import</span> <span>scala.concurrent.duration.Duration</span>
<span>import</span> <span>akka.util.Timeout</span>
<span>import</span> <span>akka.pattern.ask</span>
<span>import</span> <span>akka.actor._</span>
<span>import</span> <span>spray.util._</span>
<span>import</span> <span>spray.io._</span>

<span>class</span> <span>EchoClient</span><span>(</span><span>_ioBridge</span><span>:</span> <span>ActorRef</span><span>)</span> <span>extends</span> <span>IOClient</span><span>(</span><span>_ioBridge</span><span>)</span> <span>{</span>
  <span>var</span> <span>pingSender</span><span>:</span> <span>Option</span><span>[</span><span>ActorRef</span><span>]</span> <span>=</span> <span>None</span>

  <span>override</span> <span>def</span> <span>receive</span> <span>=</span> <span>myReceive</span> <span>orElse</span> <span>super</span><span>.</span><span>receive</span>

  <span>def</span> <span>myReceive</span><span>:</span> <span>Receive</span> <span>=</span> <span>{</span>
    <span>case</span> <span>EchoClient</span><span>.</span><span>Ping</span><span>(</span><span>handle</span><span>)</span> <span>=&gt;</span>
      <span>pingSender</span> <span>=</span> <span>Some</span><span>(</span><span>sender</span><span>)</span>
      <span>handle</span><span>.</span><span>ioBridge</span> <span>!</span> <span>IOBridge</span><span>.</span><span>Send</span><span>(</span><span>handle</span><span>,</span> <span>BufferBuilder</span><span>(</span><span>"PING"</span><span>).</span><span>toByteBuffer</span><span>)</span>

    <span>case</span> <span>IOClient</span><span>.</span><span>Received</span><span>(</span><span>handle</span><span>,</span> <span>buffer</span><span>)</span> <span>=&gt;</span>
      <span>pingSender</span><span>.</span><span>foreach</span><span>(</span><span>_</span> <span>!</span> <span>EchoClient</span><span>.</span><span>PingResponse</span><span>(</span><span>buffer</span><span>.</span><span>drainToString</span><span>))</span>

    <span>case</span> <span>IOClient</span><span>.</span><span>Closed</span><span>(</span><span>_</span><span>,</span> <span>reason</span><span>)</span> <span>=&gt;</span>
      <span>log</span><span>.</span><span>debug</span><span>(</span><span>"Connection closed: {}"</span><span>,</span> <span>reason</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>object</span> <span>EchoClient</span> <span>{</span>
  <span>case</span> <span>class</span> <span>Ping</span><span>(</span><span>handle</span><span>:</span> <span>Connection</span><span>)</span> <span>extends</span> <span>Command</span>
  <span>case</span> <span>class</span> <span>PingResponse</span><span>(</span><span>response</span><span>:</span> <span>String</span><span>)</span> <span>extends</span> <span>Event</span>
<span>}</span>

<span>class</span> <span>EchoServer</span><span>(</span><span>_ioBridge</span><span>:</span> <span>ActorRef</span><span>)</span> <span>extends</span> <span>IOServer</span><span>(</span><span>_ioBridge</span><span>)</span> <span>{</span>
  <span>override</span> <span>def</span> <span>receive</span> <span>=</span> <span>super</span><span>.</span><span>receive</span> <span>orElse</span> <span>{</span>
    <span>case</span> <span>IOServer</span><span>.</span><span>Received</span><span>(</span><span>handle</span><span>,</span> <span>buffer</span><span>)</span> <span>if</span> <span>buffer</span><span>.</span><span>duplicate</span><span>.</span><span>drainToString</span> <span>==</span> <span>"PING"</span> <span>=&gt;</span>
      <span>sender</span> <span>!</span> <span>IOBridge</span><span>.</span><span>Send</span><span>(</span><span>handle</span><span>,</span> <span>BufferBuilder</span><span>(</span><span>"PONG"</span><span>).</span><span>toByteBuffer</span><span>)</span>
      <span>sender</span> <span>!</span> <span>IOBridge</span><span>.</span><span>Close</span><span>(</span><span>handle</span><span>,</span> <span>ConnectionCloseReasons</span><span>.</span><span>CleanClose</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>val</span> <span>system</span> <span>=</span> <span>ActorSystem</span><span>()</span>

<span>val</span> <span>ioBridge</span> <span>=</span> <span>IOExtension</span><span>(</span><span>system</span><span>).</span><span>ioBridge</span><span>()</span>

<span>val</span> <span>server</span> <span>=</span> <span>system</span><span>.</span><span>actorOf</span><span>(</span><span>Props</span><span>(</span><span>new</span> <span>EchoServer</span><span>(</span><span>ioBridge</span><span>)),</span> <span>"server"</span><span>)</span>
<span>val</span> <span>client</span> <span>=</span> <span>system</span><span>.</span><span>actorOf</span><span>(</span><span>Props</span><span>(</span><span>new</span> <span>EchoClient</span><span>(</span><span>ioBridge</span><span>)),</span> <span>"client"</span><span>)</span>

<span>implicit</span> <span>val</span> <span>timeout</span><span>:</span> <span>Timeout</span> <span>=</span> <span>Duration</span><span>(</span><span>1</span><span>,</span> <span>SECONDS</span><span>)</span> <span>// timeout for the asks below</span>

<span>// bind the server to a local port and wait for it to come up</span>
<span>server</span><span>.</span><span>ask</span><span>(</span><span>IOServer</span><span>.</span><span>Bind</span><span>(</span><span>"localhost"</span><span>,</span> <span>46468</span><span>)).</span><span>await</span>

<span>// ask the client to connect to the server and wait for the connection to come up</span>
<span>val</span> <span>IOClient</span><span>.</span><span>Connected</span><span>(</span><span>handle</span><span>)</span> <span>=</span> <span>client</span><span>.</span><span>ask</span><span>(</span><span>IOClient</span><span>.</span><span>Connect</span><span>(</span><span>"localhost"</span><span>,</span> <span>46468</span><span>)).</span><span>await</span>

<span>// ping the server and wait for the response</span>
<span>val</span> <span>EchoClient</span><span>.</span><span>PingResponse</span><span>(</span><span>response</span><span>)</span> <span>=</span> <span>client</span><span>.</span><span>ask</span><span>(</span><span>EchoClient</span><span>.</span><span>Ping</span><span>(</span><span>handle</span><span>)).</span><span>await</span>

<span>response</span> <span>===</span> <span>"PONG"</span>

<span>system</span><span>.</span><span>shutdown</span><span>()</span>
</pre></div>
</div>
<p>Note than this example uses blocking calls to wait for future results, which is something that you probably do not
want to do in a performance-sensitive part of your application. Also, for brevity reasons the example omits all
error handling logic.</p>
</div>
<div>
<h2>Messaging Protocol</h2>
<p>The convention in <em>spray</em> is to make all custom message types that a certain actor consumes or sends out available
in the actors companion object. In this regard the <tt><span>IOClient</span></tt> is no exception, you can find all commands and events
that an <tt><span>IOClient</span></tt> works with in <a href="javascript://">its companion object</a></p>
</div>
</div>
<div>
<span></span><h1>IOServer</h1>
<p>The <a href="javascript://">IOServer</a> is a simple actor base class for server-side networking components.
It builds upon an <a href="javascript://"><em>IOBridge</em></a> and provides server-side connection management. An <tt><span>IOServer</span></tt> cannot be used
directly but has to be subclassed (potentially mixing in the <a href="javascript://"><em>ConnectionActors</em></a> trait) and augmented
with the custom application logic that actually does whatever the specific networking server is supposed to do.
In that sense the <tt><span>IOServer</span></tt> class merely provides the “boilerplate” logic common to most <em>spray-io</em> based network
servers.</p>
<p>After having created an <tt><span>IOServer</span></tt> actor instance you typically send it a <tt><span>Bind</span></tt> message, which causes it to listen
for incoming connections on a specific interface/port. When the server is up the sender of the <tt><span>Bind</span></tt> receives a
<tt><span>Bound</span></tt> event and subsequently a <tt><span>Connected</span></tt> event for every new connection that has been accepted.
Once bound the server can be unbound with an <tt><span>Unbind</span></tt> command.</p>
<p>In its original form, without mixing in the <a href="javascript://"><em>ConnectionActors</em></a> trait, an <tt><span>IOServer</span></tt> designates itself as the
handler of all network events. You will therefore have to augment its <tt><span>receive</span></tt> behavior with your own logic
handling incoming <tt><span>Received</span></tt> events as well as generating the appropriate <tt><span>Send</span></tt> commands.</p>
<div>
<h2>Examples</h2>
<p>One example of a network server based on the <tt><span>IOServer</span></tt> is the <em>spray-can</em> <a href="javascript://"><em>HttpServer</em></a>. You might find
<a href="javascript://">its sources</a> quite readable.</p>
<p>Another example is the <tt><span>echo-server</span></tt> implementation that can be found <a href="javascript://">here</a>.
It presents a simple echo server that you can <tt><span>telnet</span></tt> to.</p>
<p>To run it, simply check out the <em>spray</em> codebase and run <tt><span>sbt</span> <span>"project</span> <span>echo-server"</span> <span>run</span></tt>.</p>
</div>
<div>
<h2>Messaging Protocol</h2>
<p>The convention in <em>spray</em> is to make all custom message types that a certain actor consumes or sends out available
in the actors companion object. In this regard the <tt><span>IOServer</span></tt> is no exception, you can find all commands and events
that an <tt><span>IOServer</span></tt> works with in <a href="javascript://">its companion object</a></p>
</div>
</div>
<div>
<span></span><h1>ConnectionActors</h1>
<p>The <a href="javascript://">ConnectionActors</a> trait can be mixed into either an <a href="javascript://"><em>IOClient</em></a> or an <a href="javascript://"><em>IOServer</em></a> and changes their
behavior to create a fresh <tt><span>IOConnectionActor</span></tt> for every newly established connection. These “connection actors”
encapsulate connection-specific state and serve as handlers for all events coming in from the underlying
<a href="javascript://"><em>IOBridge</em></a>.</p>
<p>Theoretically, in order to implement your own client- or server logic, it would suffice if <em>spray-io</em> gave you the
ability to somehow place your own <tt><span>Actor.Receive</span></tt> partial function directly in these connection actors.
However, implementing non-trivial client- or server logic in a single, monolithic actor usually doesn’t yield very
readable and maintainable code. Rather an architecturally clean implementation would split up the logic into different,
loosely coupled chunks, each handling only one very tightly scoped aspect of the whole client or server.</p>
<p><em>spray-io</em> provides an infrastructure for this type of architecture with the concept of <a href="javascript://"><em>Pipelining</em></a>, for which
the <a href="javascript://">ConnectionActors</a> trait forms the basis.</p>
</div>
<div>
<span></span><h1>Pipelining</h1>
<p>In order to form a proper foundation for architecturally sound network client- and server implementations <em>spray-io</em>
supports <em>pipelining</em>. The basic idea is to design a client or server as a series of loosely coupled <em>pipeline stages</em>,
with each stage implementing only one tightly scoped aspect of the whole logic.
Pipeline stages can be assembled into different configurations in way that is configurable at runtime, which allows
a user of the client or server to enable or disable selected parts according to their needs.</p>
<p>The <em>spray-io</em> pipelining architecture is loosely based on the one from <a href="javascript://">Netty</a>. However, in contrast to its Java-based
“role model” it can leverage Scala language features such as pattern matching for a cleaner and more concise
implementation without sacrificing performance.</p>
<div>
<h2>Architecture</h2>
<p>The following diagram outlines the major concepts:</p>
<img src="../../../_images/pipelining.svg"><p>When a connection actor is started by its parent (which is either an <a href="javascript://"><em>IOClient</em></a> or an <a href="javascript://"><em>IOServer</em></a>) it
immediately constructs two “pipelines”, a <em>command pipeline</em> and an <em>event pipeline</em>. A pipeline consists of one or
more <em>pipeline stages</em>, through which messages travel unidirectionally.</p>
<p>In the command pipeline <tt><span>Command</span></tt> messages are passed from higher-level stages down to lower-level stages until they
hit the final stage, which, in most cases, passes them on to the underlying <a href="javascript://"><em>IOBridge</em></a>. In the event pipeline
<tt><span>Event</span></tt> message flow in the other direction, from the <a href="javascript://"><em>IOBridge</em></a> up through all its stages.</p>
<p>Pipeline stages form the entities, into which you typically structure your client or server logic. Conceptually there
are four types of stages:</p>
<ul>
<li>“Command-only stages”, which inject logic only into the command pipeline</li>
<li>“Event-only stages”, which inject logic only into the event pipeline</li>
<li>“Full stages”, which inject logic into both pipelines</li>
<li>“Empty stages”, which don’t add any logic (they serve as neutral element for pipeline combination)</li>
</ul>
</div>
<div>
<h2>The <em>PipelineStage</em> trait</h2>
<p>Pipeline stages are modelled by the <tt><span>PipelineStage</span></tt> trait, whose central element is the <tt><span>build</span></tt> method:</p>
<div><div><pre><span>def</span> <span>build</span><span>(</span><span>context</span><span>:</span> <span>PipelineContext</span><span>,</span>
          <span>commandPL</span><span>:</span> <span>Pipeline</span><span>[</span><span>Command</span><span>],</span>
          <span>eventPL</span><span>:</span> <span>Pipeline</span><span>[</span><span>Event</span><span>])</span><span>:</span> <span>Pipelines</span>
</pre></div>
</div>
<p>whereby <tt><span>Pipeline</span></tt> is the following simple type alias:</p>
<div><div><pre><span>type</span> <span>Pipeline</span><span>[</span><span>-T</span><span>]</span> <span>=</span> <span>T</span> <span>=&gt;</span> <span>Unit</span>
</pre></div>
</div>
<p>So, when seen from the outside, a pipeline appears simply as a sink for messages of specific type.</p>
<p>The <tt><span>build</span></tt> method of a <tt><span>PipelineStage</span></tt> is called every time a new connection actor is created. Apart from the
<tt><span>PipelineContext</span></tt> the <tt><span>build</span></tt> method receives its downstream “tail” pipelines as arguments.
The result of the <tt><span>build</span></tt> method is an instance of the <tt><span>Pipelines</span></tt> trait, which simply groups together the new
command and event pipelines, after the stage has prepended them with its own logic:</p>
<div><div><pre><span>trait</span> <span>Pipelines</span> <span>{</span>
  <span>def</span> <span>commandPipeline</span><span>:</span> <span>Pipeline</span><span>[</span><span>Command</span><span>]</span>
  <span>def</span> <span>eventPipeline</span><span>:</span> <span>Pipeline</span><span>[</span><span>Event</span><span>]</span>
<span>}</span>
</pre></div>
</div>
<p>The dotted lines in the following diagram illustrate what the <tt><span>build</span></tt> method returns:</p>
<img src="../../../_images/PipelineStage.svg"></div>
<div>
<h2>Execution Model</h2>
<p>Since pipelines are simple functions <tt><span>T</span> <span>=&gt;</span> <span>Unit</span></tt> (with <tt><span>T</span></tt> being either <tt><span>Command</span></tt> or <tt><span>Event</span></tt>) each stage is
in complete control of the message flow. It can not only modify messages, it can also hold, discard or multiply them in
any way. Additionally it can generate messages of the opposite type and push them into the respective downstream tail
pipeline. For example, the <a href="javascript://">RequestParsing</a> stage of the <a href="javascript://"><em>spray-can</em></a> <a href="javascript://"><em>HttpServer</em></a> generates commands
that complete a request with an error response whenever a request parsing error is encountered.</p>
<p>Also, all pipeline code is always executed in the context of the connection actor and therefore isolated to a specific
connection. As such, keeping mutable, connection-specific state within a pipeline stage is not a problem.</p>
<p>When another actor gets a hold of the connection actors <tt><span>ActorRef</span></tt> (e.g. because a pipeline stage sent an
<tt><span>IOPeer.Tell</span></tt> command using the connection actor as <tt><span>sender</span></tt>) and itself sends a message to the connection actor,
this message hits the connection actors <tt><span>receive</span></tt> behavior, which is defined like this:</p>
<div><div><pre><span>def</span> <span>receive</span><span>:</span> <span>Receive</span> <span>=</span> <span>{</span>
  <span>case</span> <span>x</span><span>:</span> <span>Command</span> <span>=&gt;</span> <span>pipelines</span><span>.</span><span>commandPipeline</span><span>(</span><span>x</span><span>)</span>
  <span>case</span> <span>x</span><span>:</span> <span>Event</span> <span>=&gt;</span> <span>pipelines</span><span>.</span><span>eventPipeline</span><span>(</span><span>x</span><span>)</span>
  <span>case</span> <span>Status</span><span>.</span><span>Failure</span><span>(</span><span>x</span><span>:</span> <span>CommandException</span><span>)</span> <span>=&gt;</span> <span>pipelines</span><span>.</span><span>eventPipeline</span><span>(</span><span>x</span><span>)</span>
  <span>case</span> <span>Terminated</span><span>(</span><span>actor</span><span>)</span> <span>=&gt;</span> <span>pipelines</span><span>.</span><span>eventPipeline</span><span>(</span><span>IOPeer</span><span>.</span><span>ActorDeath</span><span>(</span><span>actor</span><span>))</span>
<span>}</span>
</pre></div>
</div>
<p>As you can see the connection actor feeds all incoming <tt><span>Command</span></tt> or <tt><span>Event</span></tt> messages directly into its respective
pipeline. This behavior can also be useful from within a pipeline stage itself, because it allows any stage to push a
command or event into the <em>beginning</em> of the respective pipeline, rather than just its own downstream pipeline “tail”.
All that stage has to do is to send the message to its own connection actor.</p>
</div>
<div>
<h2>Creating Pipeline Stages</h2>
<p>Since the <tt><span>PipelineStage</span></tt> trait is a regular Scala trait you can implement it in any way you like. However, the
following template, which illustrates how pipeline stage implementations within <em>spray</em> itself are
structured, might give you a good starting point:</p>
<div><div><pre><span>object</span> <span>PipelineStageName</span> <span>{</span>

  <span>// members defined here are global across</span>
  <span>// all server and client instances</span>

  <span>def</span> <span>apply</span><span>(&lt;</span><span>arguments</span><span>&gt;)</span><span>:</span> <span>PipelineStage</span> <span>=</span> <span>new</span> <span>PipelineStage</span> <span>{</span>
    <span>require</span><span>(...)</span> <span>// argument verification</span>

    <span>// members defined here exist once per</span>
    <span>// server or client instance</span>

    <span>def</span> <span>build</span><span>(</span><span>context</span><span>:</span> <span>PipelineContext</span><span>,</span>
              <span>commandPL</span><span>:</span> <span>Pipeline</span><span>[</span><span>Command</span><span>],</span>
              <span>eventPL</span><span>:</span> <span>Pipeline</span><span>[</span><span>Event</span><span>])</span><span>:</span> <span>Pipelines</span> <span>=</span> <span>new</span> <span>Pipelines</span> <span>{</span>

      <span>// members defined here exist</span>
      <span>// once per connection</span>

      <span>val</span> <span>commandPipeline</span><span>:</span> <span>Pipeline</span><span>[</span><span>Command</span><span>]</span> <span>=</span> <span>{</span>
        <span>case</span> <span>...</span> <span>=&gt;</span>
          <span>// handle "interesting" commands, send commands</span>
          <span>// and events to the commandPL or eventPL</span>

        <span>case</span> <span>cmd</span> <span>=&gt;</span> <span>// pass through all "unknown" commands</span>
          <span>commandPL</span><span>(</span><span>cmd</span><span>)</span>
      <span>}</span>

      <span>val</span> <span>eventPipeline</span><span>:</span> <span>Pipeline</span><span>[</span><span>Event</span><span>]</span> <span>=</span> <span>{</span>
        <span>case</span> <span>...</span> <span>=&gt;</span>
          <span>// handle "interesting" events, send commands</span>
          <span>// and events to the commandPL or eventPL</span>

        <span>case</span> <span>ev</span> <span>=&gt;</span> <span>// pass through all "unknown" events</span>
          <span>eventPL</span><span>(</span><span>ev</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>

  <span>////////////// COMMANDS and EVENTS //////////////</span>

  <span>// definition of all commands and events specific to this pipeline stage</span>

  <span>case</span> <span>class</span> <span>MyCommand</span><span>(...)</span> <span>extends</span> <span>Command</span>
  <span>case</span> <span>class</span> <span>MyEvent</span><span>(...)</span> <span>extends</span> <span>Event</span>
<span>}</span>
</pre></div>
</div>
<p>This template shows a “full stage``, with logic injected into both pipelines. If your stage only requires logic in one
of the pipelines simply pass through the other one unchanged. For example, if your stage is a “command-only” stage you’d
implement the <tt><span>eventPipeline</span></tt> member of the <tt><span>Pipelines</span></tt> trait as such:</p>
<div><div><pre><span>val</span> <span>eventPipeline</span> <span>=</span> <span>eventPL</span>
</pre></div>
</div>
<p>Check out the <a href="javascript://">ResponseRendering</a> stage of the <a href="javascript://"><em>spray-can</em></a> <a href="javascript://"><em>HttpServer</em></a> as an
example of a “command-only stage” and the <a href="javascript://"><em>TickGenerator</em></a> as an “event-only stage” example.</p>
</div>
<div>
<h2>Combining Pipeline Stages</h2>
<p>Two <tt><span>PipelineStage</span></tt> instances can be combined into single one with the <tt><span>&gt;&gt;</span></tt> operator. Additionally an expression
creating a <tt><span>PipelineStage</span></tt> can be made optional by prepending it with a <tt><span>&lt;boolean&gt;</span> <span>?</span></tt> modifier.</p>
<p>To understand what this means check out this simplified version of the definition of the <a href="javascript://"><em>spray-can</em></a>
<a href="javascript://">HttpClient</a> pipeline:</p>
<div><div><pre><span>ClientFrontend</span><span>(...)</span> <span>&gt;&gt;</span>
<span>(</span><span>ResponseChunkAggregationLimit</span> <span>&gt;</span> <span>0</span><span>)</span> <span>?</span> <span>ResponseChunkAggregation</span><span>(...)</span> <span>&gt;&gt;</span>
<span>ResponseParsing</span><span>(...)</span> <span>&gt;&gt;</span>
<span>RequestRendering</span><span>(...)</span> <span>&gt;&gt;</span>
<span>(</span><span>settings</span><span>.</span><span>IdleTimeout</span> <span>&gt;</span> <span>0</span><span>)</span> <span>?</span> <span>ConnectionTimeouts</span><span>(...)</span> <span>&gt;&gt;</span>
<span>SslTlsSupport</span><span>(...)</span> <span>&gt;&gt;</span>
<span>(</span><span>ReapingCycle</span> <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> <span>IdleTimeout</span> <span>&gt;</span> <span>0</span><span>)</span> <span>?</span> <span>TickGenerator</span><span>(</span><span>ReapingCycle</span><span>)</span>
</pre></div>
</div>
<p>This expression constructs a single <tt><span>PipelineStage</span></tt> instance from 3 to 7 sub-stages, depending on the configuration
settings of the client. The lines containing a <tt><span>?</span></tt> operator evaluate to <tt><span>EmptyPipelineStage</span></tt> if the boolean
expression before the <tt><span>?</span></tt> is false. The <tt><span>EmptyPipelineStage</span></tt> singleton object serves as a “neutral” element when
combining pipeline stages. Its <tt><span>build</span></tt> method doesn’t append any logic to either pipeline, so “switched off”
PipelineStages do not introduce any overhead.</p>
</div>
<div>
<h2>The Final Stages</h2>
<p>Both pipelines, the command as well as the event pipeline, are always terminated by stages provided by the connection
actor itself. The following, an excerpt of the <a href="javascript://">IOConnectionActor sources</a>, is their definition:</p>
<div><div><pre><span>def</span> <span>baseCommandPipeline</span><span>:</span> <span>Pipeline</span><span>[</span><span>Command</span><span>]</span> <span>=</span> <span>{</span>
  <span>case</span> <span>IOPeer</span><span>.</span><span>Send</span><span>(</span><span>buffers</span><span>,</span> <span>ack</span><span>)</span>          <span>=&gt;</span> <span>ioBridge</span> <span>!</span> <span>IOBridge</span><span>.</span><span>Send</span><span>(</span><span>connection</span><span>,</span> <span>buffers</span><span>,</span> <span>eventize</span><span>(</span><span>ack</span><span>))</span>
  <span>case</span> <span>IOPeer</span><span>.</span><span>Close</span><span>(</span><span>reason</span><span>)</span>               <span>=&gt;</span> <span>ioBridge</span> <span>!</span> <span>IOBridge</span><span>.</span><span>Close</span><span>(</span><span>connection</span><span>,</span> <span>reason</span><span>)</span>
  <span>case</span> <span>IOPeer</span><span>.</span><span>StopReading</span>                 <span>=&gt;</span> <span>ioBridge</span> <span>!</span> <span>IOBridge</span><span>.</span><span>StopReading</span><span>(</span><span>connection</span><span>)</span>
  <span>case</span> <span>IOPeer</span><span>.</span><span>ResumeReading</span>               <span>=&gt;</span> <span>ioBridge</span> <span>!</span> <span>IOBridge</span><span>.</span><span>ResumeReading</span><span>(</span><span>connection</span><span>)</span>
  <span>case</span> <span>IOPeer</span><span>.</span><span>Tell</span><span>(</span><span>receiver</span><span>,</span> <span>msg</span><span>,</span> <span>sender</span><span>)</span> <span>=&gt;</span> <span>receiver</span><span>.</span><span>tell</span><span>(</span><span>msg</span><span>,</span> <span>sender</span><span>)</span>
  <span>case</span> <span>_:</span> <span>Droppable</span> <span>=&gt;</span> <span>// don't warn</span>
  <span>case</span> <span>cmd</span> <span>=&gt;</span> <span>log</span><span>.</span><span>warning</span><span>(</span><span>"commandPipeline: dropped {}"</span><span>,</span> <span>cmd</span><span>)</span>
<span>}</span>

<span>def</span> <span>baseEventPipeline</span><span>:</span> <span>Pipeline</span><span>[</span><span>Event</span><span>]</span> <span>=</span> <span>{</span>
  <span>case</span> <span>x</span><span>:</span> <span>IOPeer.Closed</span> <span>=&gt;</span> <span>stop</span><span>(</span><span>x</span><span>)</span>
  <span>case</span> <span>_:</span> <span>Droppable</span> <span>=&gt;</span> <span>// don't warn</span>
  <span>case</span> <span>ev</span> <span>=&gt;</span> <span>log</span><span>.</span><span>warning</span><span>(</span><span>"eventPipeline: dropped {}"</span><span>,</span> <span>ev</span><span>)</span>
<span>}</span>
</pre></div>
</div>
<p>The final stage of the command pipeline translates most of the defined messages into their <tt><span>IOBridge</span></tt> counterparts
and sends them off to the bridge. There is one command, <tt><span>IOPeer.Tell</span></tt>, which does not follow this pattern.
This command simply encapsulates an Actor <tt><span>tell</span></tt> call into a <tt><span>Command</span></tt> message. Whenever a pipeline stage would like
to send a message to an actor it should push an <tt><span>IOPeer.Tell</span></tt> command into the command pipeline rather than
calling <tt><span>actorRef.tell</span></tt> directly. This design has two benefits:</p>
<ul>
<li>Other downstream pipeline stages can react to, and maybe even modify the <tt><span>Tell</span></tt>.</li>
<li>The stage remains independently testable, without the need to fire up actors. (Check out the <a href="javascript://"><em>Testing Pipelines</em></a>
chapter for more info on this.)</li>
</ul>
<p>The final stage of the event pipeline only reacts to <tt><span>Closed</span></tt> messages. It stops the connection actor as a result.</p>
</div>
</div>
<div>
<h1>Predefined Stages</h1>
<p><em>spray-io</em> comes with a number of predefined pipeline stages, which you can “bake into” your own pipeline stack, where
you seem fit.</p>
<div>
<span></span><h2>TickGenerator</h2>
<p>The <a href="javascript://">TickGenerator</a> forms a simple <tt><span>event-only</span> <span>stage</span></tt> that generates <tt><span>Tick</span></tt> events in regular intervals.
This is its implementation:</p>
<blockquote>
<div></div></blockquote>
<div><div><pre><span>object</span> <span>TickGenerator</span> <span>{</span>

  <span>def</span> <span>apply</span><span>(</span><span>millis</span><span>:</span> <span>Long</span><span>)</span><span>:</span> <span>PipelineStage</span> <span>=</span> <span>apply</span><span>(</span><span>Duration</span><span>(</span><span>millis</span><span>,</span> <span>MILLISECONDS</span><span>))</span>

  <span>def</span> <span>apply</span><span>(</span><span>period</span><span>:</span> <span>FiniteDuration</span><span>)</span><span>:</span> <span>PipelineStage</span> <span>=</span> <span>{</span>
    <span>require</span><span>(</span><span>period</span> <span>&gt;</span> <span>Duration</span><span>.</span><span>Zero</span><span>,</span> <span>"period must be positive"</span><span>)</span>

    <span>new</span> <span>PipelineStage</span> <span>{</span>
      <span>def</span> <span>build</span><span>(</span><span>context</span><span>:</span> <span>PipelineContext</span><span>,</span> <span>commandPL</span><span>:</span> <span>CPL</span><span>,</span> <span>eventPL</span><span>:</span> <span>EPL</span><span>)</span><span>:</span> <span>Pipelines</span> <span>=</span>
        <span>new</span> <span>Pipelines</span> <span>{</span>
          <span>val</span> <span>generator</span> <span>=</span> <span>{</span>
            <span>val</span> <span>system</span> <span>=</span> <span>context</span><span>.</span><span>connectionActorContext</span><span>.</span><span>system</span>
            <span>system</span><span>.</span><span>scheduler</span><span>.</span><span>schedule</span><span>(</span>
              <span>initialDelay</span> <span>=</span> <span>period</span><span>,</span>
              <span>interval</span> <span>=</span> <span>period</span><span>,</span>
              <span>receiver</span> <span>=</span> <span>context</span><span>.</span><span>self</span><span>,</span>
              <span>message</span> <span>=</span> <span>Tick</span>
            <span>)(</span><span>system</span><span>.</span><span>dispatcher</span><span>)</span>
          <span>}</span>

          <span>val</span> <span>commandPipeline</span> <span>=</span> <span>commandPL</span>

          <span>val</span> <span>eventPipeline</span><span>:</span> <span>EPL</span> <span>=</span> <span>{</span>
            <span>case</span> <span>x</span><span>:</span> <span>IOPeer.Closed</span> <span>=&gt;</span>
              <span>generator</span><span>.</span><span>cancel</span><span>()</span>
              <span>eventPL</span><span>(</span><span>x</span><span>)</span>
            <span>case</span> <span>x</span> <span>=&gt;</span> <span>eventPL</span><span>(</span><span>x</span><span>)</span>
          <span>}</span>
        <span>}</span>
    <span>}</span>
  <span>}</span>

  <span>////////////// COMMANDS //////////////</span>
  <span>case</span> <span>object</span> <span>Tick</span> <span>extends</span> <span>Event</span> <span>with</span> <span>Droppable</span>
<span>}</span>
</pre></div>
</div>
<p>The <tt><span>TickGenerator</span></tt> provides the triggers for all timeout checking stages in <em>spray-io</em> and <a href="javascript://"><em>spray-can</em></a>, but, of
course, you can also use it for other purposes.</p>
</div>
<div>
<span></span><h2>ConnectionTimeouts</h2>
<p>The <a href="javascript://">ConnectionTimeouts</a> pipeline stage provides support for the automatic closing of idle connection after a
configurable time period. The stage is modeled as a <tt><span>full</span> <span>stage</span></tt> that listens for outgoing <tt><span>Send</span></tt> commands
as well as incoming <tt><span>Received</span></tt> events and updates a <tt><span>lastActivity</span></tt> timestamp, whenever it sees one such message.</p>
<p>It requires a <a href="javascript://">TickGenerator</a> stage further down in the stack and uses its <tt><span>Tick</span></tt> messages as a trigger for checking,
whether the connection has been idle for longer than the allowed time frame. If so, a <tt><span>Close</span></tt> command is issued.</p>
</div>
<div>
<h2>SslTlsSupport</h2>
<p>The <a href="javascript://">SslTlsSupport</a> pipeline stage provides for transparent encryption of outgoing <tt><span>Send</span></tt> commands as well as
decryption of incoming <tt><span>Received</span></tt> commands. Just add it as a lower-level stage to your pipeline stack, whenever you
need SSL/TLS encryption, and all your network communication can be SSL encrypted automatically.</p>
<p>The <tt><span>SslTlsSupport</span></tt> also allows for the enabling/disabling of the encryption stage on a per-connection basis.
This is controlled via the connection “tag”, check the <a href="javascript://"><em>Connection Tags</em></a> chapter for more info on this.
If the connection tag does not implement the <tt><span>SslTlsSupport.Enabling</span></tt> trait the decision, whether to encrypt the
connection or not, is determined via the <tt><span>encryptIfUntagged</span></tt> parameter specified at pipeline stage creation.</p>
<p>The <tt><span>SslTlsSupport</span></tt> stage requires also requires an <tt><span>engineProvider</span></tt> parameter, which is a function
<tt><span>PipelineContext</span> <span>=&gt;</span> <span>SSLEngine</span></tt>. The easiest way to specify an argument for this parameter is to use the default
<tt><span>ServerSSLEngineProvider</span></tt> or <tt><span>ClientSSLEngineProvider</span></tt>, depending on whether you are using the encryption stage
on the client- or the server-side, e.g.:</p>
<div><div><pre><span>val</span> <span>engineProvider</span> <span>=</span> <span>ServerSSLEngineProvider</span><span>.</span><span>default</span>
</pre></div>
</div>
<p>In order to make this line compile you also need to bring into scope either an implicit <tt><span>javax.net.ssl.SSLContext</span></tt>
or an implicit <tt><span>SSLContextProvider</span></tt>.</p>
</div>
</div>
<div>
<span></span><h1>Connection Tags</h1>
<p>Every connection (handle) has a custom <tt><span>tag:</span> <span>Any</span></tt> member that it initially receives from the command that triggered
the connection, which is either the <tt><span>Bind</span></tt> for server-side or <tt><span>Connect</span></tt> for client-side connections.</p>
<p>Additionally the connection tag can be changed right before a new handle is registered by overriding the
<tt><span>connectionTag</span></tt> method (from the <tt><span>ConnectionActors</span></tt> trait), which is especially useful for servers that would like
to attach individual tags to accepted connections and not use (the same) <tt><span>Bind</span></tt> tag for all of them.</p>
<p>Currently there are three uses for connection tags:</p>
<ol>
<li><p>Enable/disable encryption on a per-connection basis by having the tag object implement the <tt><span>SslTlsSupport.Enabling</span></tt>
trait:</p>
<div><div><pre><span>/**</span>
<span> * Interface that can be implemented by a `tag` object on the connection</span>
<span> * in order to determine whether encryption on the connection is to be</span>
<span> * enabled or not.</span>
<span> */</span>
<span>trait</span> <span>Enabling</span> <span>{</span>
  <span>def</span> <span>encrypt</span><span>(</span><span>ctx</span><span>:</span> <span>PipelineContext</span><span>)</span><span>:</span> <span>Boolean</span>
<span>}</span>
</pre></div>
</div>
<p>If the tag does not implement this trait the default setting applies, which is specified as an argument to the
<tt><span>SslTlsSupport</span></tt> pipeline stage creator. (For example, the <em>spray-can</em> <a href="javascript://"><em>HttpClient</em></a> has a default of
“not encrypted” and the <em>spray-can</em> <a href="javascript://"><em>HttpServer</em></a> a default of “encrypted”, when the
<tt><span>spray.can.server.ssl-encryption</span></tt> config setting is enabled and <tt><span>SslTlsSupport</span></tt> available.)</p>
</li>
<li><p>Enable log marking: If the tag object implements the new <tt><span>spray.io.LogMarking</span></tt> trait all log messages produced by
the <em>spray-io</em> and <em>spray-can</em> layers for this connection will be prefixed with the respective log marker string.
This allows for easy grepping of all log messages related to a specific connection across all layers, even in massive
logs. The respective log logic is also accessible for your custom layers on top of <em>spray-io</em> / <em>spray-can</em> via the
<tt><span>spray.io.TaggableLog</span></tt> facility.</p>
</li>
<li><p>Custom uses: Since your code has access to the tag from everywhere, including custom pipeline stages, tags can be
used as a channel for any kind of custom data needs.</p>
</li>
</ol>
</div>
<div>
<span></span><h1>Testing Pipelines</h1>
<p>Besides the architectural cleanliness a nice side effect of <em>spray-ios</em> <a href="javascript://"><em>Pipelining</em></a> architecture is that you can test
individual pipeline stages, or complete stacks of them, easily and without the need to fire up actors.</p>
<p><em>spray-io</em> comes with the <a href="javascript://">PipelineStageTest</a> trait, which you can mix into any test specification. It gives you a
small DSL that allows for convenient testing of a pipeline stage (which can also be a combination of sub stages).</p>
<p>As an example you might want to take a look at the <a href="javascript://">ConnectionTimeoutsSpec</a>, which tests the <a href="javascript://"><em>ConnectionTimeouts</em></a>
pipeline stage.</p>
<div>
<h2>Overview</h2>
<p>The <tt><span>PipelineStageTest</span></tt> trait contains a “pimp” for <tt><span>PipelineStage</span></tt> instances, which gives you a <tt><span>test</span></tt> method
taking a body of test code:</p>
<div><div><pre><span>val</span> <span>stage</span><span>:</span> <span>PipelineStage</span> <span>=</span> <span>...</span>
<span>stage</span><span>.</span><span>test</span> <span>{</span>
  <span>...</span> <span>// test code</span>
<span>}</span>
</pre></div>
</div>
<p>The code running “inside” of the <tt><span>test</span></tt> method has access to a number of helpers allowing for pushing commands and
events through the pipeline stage and inspecting the produced messages.</p>
</div>
<div>
<h2>Process</h2>
<p>The most important helper is <tt><span>process</span></tt>:</p>
<div><div><pre><span>def</span> <span>process</span><span>(</span><span>cmdsAndEvents</span><span>:</span> <span>AnyRef*</span><span>)</span><span>:</span> <span>ProcessResult</span> <span>=</span>
</pre></div>
</div>
<p>It allows you to push a number of commands and/or events into the respective ends of the pipeline stage and collect
the commands and events produced by the stage:</p>
<div><div><pre><span>val</span> <span>stage</span><span>:</span> <span>PipelineStage</span> <span>=</span> <span>...</span>
<span>stage</span><span>.</span><span>test</span> <span>{</span>
  <span>val</span> <span>result</span> <span>=</span> <span>process</span><span>(</span><span>MyCommand</span><span>,</span> <span>MyEvent</span><span>)</span>
  <span>...</span>
<span>}</span>
</pre></div>
</div>
<p>The result produced by the <tt><span>process</span></tt> method is an instance of <tt><span>ProcessResult</span></tt>, which is defined as such:</p>
<div><div><pre><span>case</span> <span>class</span> <span>ProcessResult</span><span>(</span><span>commands</span><span>:</span> <span>List</span><span>[</span><span>Command</span><span>],</span> <span>events</span><span>:</span> <span>List</span><span>[</span><span>Event</span><span>])</span>
</pre></div>
</div>
<p>It contains a “snapshot” of the current state of the internal message collector. If you call <tt><span>process</span></tt> several times
the collected messages will accumulate. So, this snippet:</p>
<div><div><pre><span>process</span><span>(</span><span>MyCommand</span><span>)</span>
<span>val</span> <span>result</span> <span>=</span> <span>process</span><span>(</span><span>MyEvent</span><span>)</span>
</pre></div>
</div>
<p>is equivalent to this one:</p>
<div><div><pre><span>val</span> <span>result</span> <span>=</span> <span>process</span><span>(</span><span>MyCommand</span><span>,</span> <span>MyEvent</span><span>)</span>
</pre></div>
</div>
<p>You can clear the message collector with <tt><span>clear()</span></tt>. Also there are two variants of <tt><span>process</span></tt>, which combine it with
a <tt><span>clear()</span></tt>:</p>
<div><div><pre><span>def</span> <span>clearAndProcess</span><span>(</span><span>cmdsAndEvents</span><span>:</span> <span>AnyRef*</span><span>)</span><span>:</span> <span>ProcessResult</span> <span>=</span> <span>{</span>
  <span>clear</span><span>()</span>
  <span>process</span><span>(</span><span>cmdsAndEvents</span><span>.</span><span>toList</span><span>)</span>
<span>}</span>

<span>def</span> <span>processAndClear</span><span>(</span><span>cmdsAndEvents</span><span>:</span> <span>AnyRef*</span><span>)</span><span>:</span> <span>ProcessResult</span> <span>=</span> <span>{</span>
  <span>val</span> <span>x</span> <span>=</span> <span>process</span><span>(</span><span>cmdsAndEvents</span><span>.</span><span>toList</span><span>)</span>
  <span>clear</span><span>()</span>
  <span>x</span>
<span>}</span>
</pre></div>
</div>
</div>
<div>
<h2>Extractors</h2>
<p>Once you have a <tt><span>ProcessResult</span></tt> instance you could “manually” inspect it and express assertions against its contents
using the constructs of your test framework. For example, using <a href="javascript://">specs2</a>, you might say something like this:</p>
<div><div><pre><span>val</span> <span>stage</span><span>:</span> <span>PipelineStage</span> <span>=</span> <span>...</span>
<span>stage</span><span>.</span><span>test</span> <span>{</span>
  <span>val</span> <span>result</span> <span>=</span> <span>process</span><span>(</span><span>MyCommand</span><span>,</span> <span>MyEvent</span><span>)</span>
  <span>result</span><span>.</span><span>commands</span><span>(</span><span>0</span><span>)</span> <span>===</span> <span>MyFirstExpectedCommand</span>
  <span>result</span><span>.</span><span>commands</span><span>(</span><span>1</span><span>)</span> <span>===</span> <span>MySecondExpectedCommand</span>
<span>}</span>
</pre></div>
</div>
<p>However, this manual decomposition of the <tt><span>ProcessResult</span></tt> can become tedious for more complex checks.
Using the simple <tt><span>Commands</span></tt> extractor that the <tt><span>PipelineStageTest</span></tt> trait provides the test becomes a bit better to
read:</p>
<div><div><pre><span>val</span> <span>stage</span><span>:</span> <span>PipelineStage</span> <span>=</span> <span>...</span>
<span>stage</span><span>.</span><span>test</span> <span>{</span>
  <span>val</span> <span>Commands</span><span>(</span><span>first</span><span>,</span> <span>second</span><span>)</span> <span>=</span> <span>process</span><span>(</span><span>MyCommand</span><span>,</span> <span>MyEvent</span><span>)</span>
  <span>first</span> <span>===</span> <span>MyFirstExpectedCommand</span>
  <span>second</span> <span>===</span> <span>MySecondExpectedCommand</span>
<span>}</span>
</pre></div>
</div>
<p>There is also an <tt><span>Events</span></tt> extractor that allows you to pattern match against the collected event messages.</p>
</div>
<div>
<h2>Message Conditioning</h2>
<p>Writing tests using <tt><span>Send</span></tt> commands and <tt><span>Received</span></tt> messages can be a bit inconvenient, since both of them carry
their content in binary form as byte arrays wrapped by a <tt><span>java.nio.ByteBuffer</span></tt>. To simplify test code the
<tt><span>PipelineStageTest</span></tt> therefore automatically converts <tt><span>Send</span></tt> commands into <tt><span>SendString</span></tt> commands, which allow
you directly test against String literals:</p>
<div><div><pre><span>val</span> <span>Commands</span><span>(</span><span>msg</span><span>)</span> <span>=</span> <span>process</span><span>(...)</span>
<span>msg</span> <span>===</span> <span>SendString</span><span>(</span><span>"expected content"</span><span>)</span>
</pre></div>
</div>
<p>The same is done on the event-side to <tt><span>Received</span></tt> events, which are automatically converted to <tt><span>ReceivedString</span></tt>
events.</p>
<p>Additionally the <tt><span>PipelineStageTest</span></tt> trait provides helpers to create <tt><span>Send</span></tt> and <tt><span>Received</span></tt> commands directly
from strings:</p>
<div><div><pre><span>process</span><span>(</span><span>Received</span><span>(</span><span>"received content"</span><span>),</span> <span>Send</span><span>(</span><span>"sent content"</span><span>))</span>
</pre></div>
</div>
</div>
<div>
<h2>Messages to and from Actors</h2>
<p>Sometimes pipelines stage logic needs to use the <tt><span>sender</span></tt> reference of an incoming message. In order to simulate the
reception of a message from a specific sender the <tt><span>PipelineStageTest</span></tt> provides the <tt><span>Message</span></tt> type:</p>
<div><div><pre><span>case</span> <span>class</span> <span>Message</span><span>(</span><span>msg</span><span>:</span> <span>AnyRef</span><span>,</span> <span>sender</span><span>:</span> <span>ActorRef</span><span>)</span>
</pre></div>
</div>
<p>For example, to feed the pipeline stage with a <tt><span>Send</span></tt> command sent by <tt><span>sender1</span></tt> you would say:</p>
<div><div><pre><span>process</span><span>(</span><span>Message</span><span>(</span><span>Send</span><span>(</span><span>"sent content"</span><span>),</span> <span>sender1</span><span>))</span>
</pre></div>
</div>
<p>In order to be able to verify that a pipeline stage sends the expected messages to other actors all pipeline stages
should use the <tt><span>IOPeer.Tell</span></tt> command, rather than sending the message directly. Not only does this allow you to treat
message sending like any other command (and verify it using the techniques explained above), it also allows other
downstream stages in the command pipeline to see the <tt><span>Tell</span></tt> and potentially modify or react to it.</p>
</div>
</div>
<div>
<h1>Examples</h1>
<p>The <tt><span>/examples/spray-io/</span></tt> directory of the <em>spray</em> repository
contains a number of example projects for <em>spray-io</em>, which are described here.</p>
<div>
<h2>echo-server</h2>
<p>This example demonstrates how you can create a very simple network server with <em>spray-io</em>.</p>
<p>Follow these steps to run it on your machine:</p>
<ol>
<li><p>Clone the <em>spray</em> repository:</p>
<div><div><pre><span>git</span> <span>clone</span> <span>git</span><span>://</span><span>github</span><span>.</span><span>com</span><span>/</span><span>spray</span><span>/</span><span>spray</span><span>.</span><span>git</span>
</pre></div>
</div>
</li>
<li><p>Change into the base directory:</p>
<div><div><pre><span>cd</span> <span>spray</span>
</pre></div>
</div>
</li>
<li><p>Run SBT:</p>
<div><div><pre><span>sbt</span> <span>"project echo-server"</span> <span>run</span>
</pre></div>
</div>
<p>(If this doesn’t work for you your SBT runner cannot deal with grouped arguments. In this case you’ll have to
run the commands <tt><span>project</span> <span>echo-server</span></tt> and <tt><span>run</span></tt> sequentially “inside” of SBT.)</p>
</li>
<li><p>Run <tt><span>telnet</span> <span>localhost</span> <span>23456</span></tt>, type something and press RETURN</p>
</li>
<li><p>Type <tt><span>STOP</span></tt> to exit</p>
</li>
</ol>
</div>
</div>